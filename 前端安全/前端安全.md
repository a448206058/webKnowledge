[](https://cloud.tencent.com/developer/article/1410405)

[](https://juejin.cn/post/6844903684900388871)

[](https://juejin.cn/post/6844903842635579405)

### XSS攻击
XSS（Cross-Site Scripting，跨站脚本攻击）是一种代码注入攻击。

根据攻击的来源，XSS攻击可以分为存储型（持久性）、反射性（非持久型）和DOM型三种

* 反射型XSS
当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等，未进行过滤直接返回到用户的浏览器上。

攻击步骤：
1. 攻击者构造出特殊的URL，其中包含恶意代码
2. 用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

防御：
对字符串进行编码：对url的查询参数进行转义后再输出到页面。
```JavaScript
app.get('/welcome', function(req, res){
    // 对查询参数进行编码，避免反射型XSS攻击
    res.send(`${encodeURIComponent(req.query.type)}`);
})
```

* DOM型XSS
DOM型XSS攻击，实际上就是前端JavaScript代码不够严谨，把不可信的内容插入到了页面。在使用.innerHTML、outerHTML、appendChild、document.write()等API时要特别小心，不要把不可信的数据作为HTML插到页面上，尽量使用.innerText、.textContent、.setAttribute()等。

攻击步骤：
1. 攻击者构造出特殊数据，其中包含恶意代码
2. 用户浏览器执行了恶意代码
3. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

防御：
防范DOM型XSS攻击的核心就是对输入内容进行转义（DOM中的内联事件监听器和链接跳转都能把字符串作为代码运行，需要对其内容进行检查）。
1. 对于url链接，直接使用encodeURIComponent转义
2. 非url
```JavaScript
function encodeHtml(str) {
    return str.replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
            .replace(/&/g, '&amp;')
            .replace(/\//g, '&#x2F;')
}
```
* 对于链接跳转，如<a href="xxx">或location.href="xxx"，要检验其内容，禁止javascript:开头的链接，和其他非法的scheme
* HTML转义是非常复杂的，在不同的情况下要采用不同的转义规则。如果采用了错误的转义规则，很有可能会埋下XSS隐患。
* 应当尽量避免自己写转义库，而应当采用成熟的、业界通用的转义库。

* 存储型XSS
恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。存储型XSS攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出。

攻击步骤：
1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

防御：
1. 前端数据传递给服务器之前，先转义/过滤
2. 服务器接收到数据，在存储到数据库之前，进行转义/过滤
3. 前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤

4. Content Security Policy
在服务端使用HTTP的Content-Security-Policy头部来指定策略，或者在前端设置meta标签

```JavaScript
// 服务端
Content-Security-Policy: default-src 'self'

// 客户端
<meta http-equiv="Content-Security-Policy" content="form-action 'self';">
```
严格的CSP在XSS的防范中可以起到以下的作用：
禁止加载外域代码，防止复杂的攻击逻辑
禁止外域提交，网站被攻击后，用户的数据不会泄露到外域
禁止内联脚本执行
禁止未授权的脚本执行
合理使用上报可以及时发现XSS，利于尽快修复问题

5. 输入内容长度控制
6. 输入内容限制（可以限定不能包含特殊字符或者仅能输入数字等）
7. HTTP-only Cookie:禁止JavaScript读取敏感Cookie
8. 验证码：防止脚本冒充用户提交危险操作

### CSRF
CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击网站执行某项操作的目的。

常见的攻击类型：
* GET类型的CSRF
* POST类型的CSRF
* 链接类型的CSRF

防御：
1. 添加验证码
2. 判断请求的来源：检测Referer(并不安全，Referer可以被更改)
3. 使用Token
4. Samesute Cookie属性
Goole起草了一份草案来改进HTTP协议，为Set-Cookie响应头新增Samesite属性，它用来标明这个Cookie是个同站Cookie，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite有俩个属性值，分别是Strict和Lax,部署简单，并能有效防御CSRF攻击，但是存在兼容性问题。

### 点击劫持
点击劫持是指在一个Web页面中隐藏了一个透明的iframe,用外层假页面诱导用户点击，实际上是在隐藏的frame上触发了点击事件进行一些用户不知情的操作

攻击流程：
1. 攻击者构建了一个非常有吸引力的网页
2. 将被攻击的页面放置在当前页面的iframe中
3. 使用样式将iframe叠加到非常有吸引力内容的上方
4. 将iframe设置为100%透明
5. 你被诱导点击了网页内容，你以为你点击的是**,实际上，你成功被攻击了

防御：
1. frame busting
```JavaScript
if (top.location != window.location) {
    top.location = window.location
}
```
HTML5中国的iframe的sandbox属性、IE中iframe的security属性等，都可以限制iframe页面中的JavaScript脚本执行，从而可以使得frame busting失效。
2. X-Frame-Options
X-Frame-Options是微软提出的一个HTTP头，专门用来防御利用iframe嵌套的点击劫持攻击
DENY:拒绝任何域加载
SAMEORIGIN:允许同源域下加载
ALLOW-FROM:可以定义允许frame加载的页面地址

### 防御工具
1. Arachni
2. Mozilla HTTP Observatory
3. w3af


## 同源策略：为什么XMLHttpRequest不能跨域请求资源？
浏览器安全可以分为三大块：
* Web页面安全
* 浏览器网络安全
* 浏览器系统安全

页面中最基础、最核心的安全策略：**同源策略（Same-origin policy**

### 什么是同源策略
* 如果俩个URL的协议、域名和端口都相同，我们就称这俩个URL同源。

同源策略主要表现在DOM、Web数据和网络三个方面

* DOM层面：同源策略限制了来自不同源的JavaScript脚本对当前DOM对象读和写的操作。
* 数据层面： 同源策略限制了不同源的站点读取当前站点的缓存数据
* 网络层面： 限制了异步请求

### 安全和便利性的权衡
同源策略会隔离不同源的DOM、页面数据和网络通信，进而实现Web页面的安全性。

安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施，但这也会使得Web项目难以开发和使用。

### 页面中可以嵌入第三方资源

为了解决XSS攻击，浏览器中引入了内容安全策略，称为CSP。CSP的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联JavaScript代码。通过这些手段就可以大大减少XSS攻击。

### 跨域资源共享和跨文档消息机制
跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使数据传输得以安全进行。

如果俩个页面不是同源的，则无法相互操纵DOM。于是浏览器中又隐去了跨文档消息机制，可以通过window.postMessage的JavaScript接口来和不同源的DOM进行通信。

## 安全沙箱： 页面和系统之间的隔离墙
浏览器被划分为浏览器内核和渲染内核

浏览器内核是由网络进程、浏览器主进程和GPU进程组成的，渲染内核就是渲染进程

浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程再执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过IPC转发给渲染进程。

安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。

### 站点隔离
是指Chrome将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。

