## 本文章学习自 深入浅出node.js 感谢朴灵大佬
## Node的诞生历程
为什么是JavaScript?
设计高性能，Web服务器的几个要点：事件驱动、非阻塞I/O
Node发展为一个强制不共享任何资源的单线程、单进程系统，包含十分适宜网络的库，为构建大型分布式应用程序提供
基础设施，其目标也是成为一个构建快速、可伸缩的网络应用平台。
它自身非常简单，通过通信协议来组织许多Node，非常容易通过扩展来达成构建大型网络应用的目的。每一个Node进程都
构成这个网络应用中的一个节点。

 Chrome						Node
 HTML JavaScript			JavaScript
 WebKit V8					V8
 中间层						中间层（libuv）
 网卡 硬盘 显卡 ...			网卡 硬盘 ...
 
 Node的结构与Chrome十分相似。它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node通过事件
 驱动来服务I/O。

### Node的特点
保留了前端浏览器JavaSript中哪些熟悉的接口，没有改写语言本身的任何特性，依旧基于作用域和原型链

在Node中，绝大多数的操作都以异步的方式进行调用。在底层构建来很多异步I/O的API，从文件读取到网络请求等。
这样的意义在于，在Node中，我们可以从语言层面很自然地进行并行I/O操作。每个调用之间无须等待之前的I/O调用结束。

CPU密集型应用给Node带来的挑战主要是：
由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。
但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O
的好处，又能充分利用CPU。

Node虽然没有提供多线程用于计算支持，但是还是有以下俩个方式来充分利用CPU。
	Node可以通过编写C/C++扩展的方式更高效地利用CPU
	如果单线程的Node不能满足需求，甚至用了C/C++扩展后还觉得不够，那么通过子进程的方式，将一部分Node进程当作常驻服务
	进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样还能充分利用多CPU。

### Node的使用者
	前后端编程语言环境统一。
	Node带来的高性能I/O用于实时应用。
		将Node应用在长连接
	并行I/O使得使用者可以更高效地利用分布式环境。
	并行I/O,有效利用稳定接口提升Web渲染能力。
	云计算平台提供Node支持 wrj18173861301
	游戏开发领域。
	工具类应用
	
## JavaScript的经历
	工具（浏览器兼容）-> 组件（功能模块）->框架（功能模块组织）->应用（业务模块组织）

## CommonJS规范
	CommonJS对模块的定义十分简单，主要分为模块引用、模块定义和模块标识3个部分。
	1.模块引用
		require()方法
	2.模块定义
		exports对象用于导出当前模块的方法或者变量
	3.模块标识
2.2 Node的模块实现
	在Node中引入模块，需要经历如下3个步骤。
		1）路径分析
		2）文件定位
		3）编译执行
	在Node中，模块分为俩类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。
		核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块
		引入时，文件定位和编译执行这俩个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。
		文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。
	优先从缓存加载
		浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。
		不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查
		先于文件模块的缓存检查。
	
	路径分析和文件定位
		1.模块标识符分析
			模块标识符在Node中主要分为以下几类
			核心模块，如http、fs、path等
			.或..开始的相对路径文件模块
			以/开始的绝对路径文件模块
			非路径形式的文件模块，如自定义的connect模块
				模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。
				1）创建module_path.js文件
				2）将其放到任意一个目录中然后执行node module_path.js
				[ 'c:\\nodejs\\node_modules', 'c:\\node_modules' ]
				模块路径的生成规则如下：
					当前文件目录下的node_modules目录
					父目录下的node_modules目录。
					父目录的父目录下的node_modules目录
					沿路径向上逐级递归，直到根目录下的node_modules目录
				它的生成方式与JavaScript的原型链或作用域链的查找方式十分类似。在加载的过程中，Node会逐个尝试模块路径中的路径，直到找到目标
				文件为止。
		2.文件定位
			文件扩展名分析
			require()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。这种情况下，Node会按.js、.json、.node的次序补足扩展名，依次尝试。
			在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为Node是单线程的，所以这里是一个会引起性能问题的地方。一个小诀窍是带上扩展名。
			另一个是：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。
			目录分析和包
			Node在当前目录下查找package.json，通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，
			将会进入扩展名分析的步骤。
		3.模块编译
			在Node中，每个文件模块都是一个对象
			编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有
			所不同，具体如下
				.js文件。通过fs模块同步读取文件后编译执行
				.node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件
				.json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。
				其余扩展名文件。它们都被当作.js文件载入。
		
2.3 核心模块
	Node的核心模块在编译成可执行文件的过程中被编译进了二进制文件。c/C++放在src下，js放在lib下

2.6 包与NPM
	在模块之外，包和NPM是将模块联系起来的一种机制。
	CommonJS包规范是理论，NPM是其中的一种实践。
	
## 异步I/O
与Node面向网络设计有关
只有后端能够快速响应资源，才能让前端的体验变好。

多想成的代价在于创建线程和执行期线程上下文切换的开销较大。
通常I/O与CPU计算之间是可以并行进行的。
Node利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程远离阻塞，以更好地使用CPU.

操作系统内核对于I/O只有俩种方式：阻塞与非阻塞。
阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。
非阻塞I/O调用之后立即返回

轮询：
read
select
poll
epoll 如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历
查询，所以不会浪费CPU，执行效率较高
kqueue

3.3 Node的异步I/O
完成整个异步I/O环节的有事件循环、观察者和请求对象、I/O线程池。

3.5 事件驱动与高性能服务器
通过主循环加事件触发的方式来运行程序。

## 4 异步编程
4.1函数式编程
高阶函数
偏函数用法

4.2异步编程的优势与难点
优势
难点
4.3异步编程解决方案
事件发布/订阅模式
Promise/Deferred模式
	Promises/A
	Prmises操作只会处在3种状态的一种：未完成态、完成态和失败态。
	Promise的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化。
	Promise的状态一旦转化，将不能被更改。


流程控制库

资料来源：朴灵大佬的深入浅出node.js
