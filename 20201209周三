// 1． 第一个记忆周期：5分钟
// 2． 第二个记忆周期：30分钟 20201209 19:30
// 3． 第三个记忆周期：12小时 20201210 07:00
// 4． 第四个记忆周期：1天 20201210 19:00
// 5． 第五个记忆周期：2天 20201211 19:00
// 6． 第六个记忆周期：4天 20201213 19:00
// 7． 第七个记忆周期：7天 20201216 19:00
// 8． 第八个记忆周期：15天 20201223

// 手写Bind  --1-- 20201209 14:46 --2-- 15:56 --3-- 20201210 08:59 --4-- 20201210 19:42 --5-- 20201211 19:31
// --6-- 20201213 19:18
/*
bind
bind()方法会创建一个新函数。当这个新函数被调用时，bind()的第一个参数将作为它运行时的this,之后一系列参数将会在传递的
实参前传入作为它的参数。
    俩个特点：
    1.返回一个函数
2.可以传入参数
 */
Function.prototype.bind2 = function(context){
    if(typeof this !== 'function'){
        throw new Error("Function.prototype.bind - what is trying to be called a bound");
    }
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function(){};
    var fBound = function(){
        var bindArgs = Array.prototype.slice.call(arguments);
        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }
    fNOP.prototype = self.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}

//实现一个JS函数柯里化 --1-- 16:03 --2-- 16:29 --3-- 20201210 09:20  --4-- 20201210 19:58  --5-- 20201211 19:42
--6-- 20201213 19:24
//在计算机科学中，柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回
//接受余下的参数且返回结果的新函数的技术。
//函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行

function curry(fn, curryArgs){
    var args = [].slice.call(arguments);

    if(curryArgs !== undefined){
        args = args.concat(curryArgs);
    }
    if(args.length < fn.length){
        return curry(fn, args);
    }
    return fn.apply(null, args);
}
/*
    算法
        从浏览器缓存淘汰策略和vue的keep-alive学习LRU算法  --1-- 20201209 11:25  --2-- 20201210 00:09 --3-- 20201210 09:29 --4-- 20201210 20:08 --5-- 20201211 19:43
        --6-- 20201213 19:27
        一、LRU缓存淘汰策略
            常见的淘汰策略有FIFO（先进先出）、LFU（最少使用）、LRU（最近最少使用）
            核心思想是如果数据最近被访问过，那么将来被访问的几率也更高，优先淘汰最近没有被访问到的数据
        二、LRU在keep-alive(vue)上的实现
            keep-alive在vue中用于实现组件的缓存，当组件切换时不会对当前组件进行卸载。
            <keep-alive>
                <component :is="view"></component>
            </keep-alive>
            最常见的俩个属性：include、exculde 用于组件进行有条件的缓存
            在2.5.0中，keep-alive新增了max属性，运用了LRU算法
       三、leetcode:LRU缓存机制
           var LRUCache = function(capacity) {
               this.cache = new Map()
               this.capacity = capacity
           }

           LRUCache.prototype.get = function(key) {
               if (this.cache.has(key)) {
                   let temp = this.cache.get(key)
                   this.cache.delete(key)
                   this.cache.set(key, temp)
                   return temp
               }
               return -1
           }

           LRUCache.prototype.put = function(key, value) {
               if(this.cache.has(key)) {
                   this.cache.delete(key)
               } else if (this.cache.size >= this.capacity) {
                   this.cache.delete(this.cache.keys().next().value)
               }
               this.cache.set(key, value)
           }

*/

/*
    vue知识
        vuex是什么？  --1-- 20201209 16:56 --2-- 17:24 --3-- 20201210 09:30  --4-- 20201210 20:13 --5-- 20201211 19:45
        --6-- 20201213 19:33
            vuex是一个专为vue.js应用程序开发的状态管理模式。每一个vuex应用核心就是store（仓库）。store就是一个容器，它包含着你的应用中大部分状态。
            vuex的状态存储是响应式的。当vue组件从store中读取状态的时候，若store中的状态发生变化，那么响应的组件也会得到高效更新。
            改变store中的状态的唯一途径就是显式地提交mutation。这样使得我们可以方便地跟踪每一个状态的变化。
            主要包含了以下几个模块：
            State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
            Getter: 允许组件从store中获取数据，mapGetters辅助函数仅仅是将store中的getter映射到局部计算属性。
            Mutation：是唯一更改store中状态的方法，且必须是同步函数
            action: 用于提交mutation，而不是直接变更状态，可以包含任意异步操作
            module:允许将单一的store拆分为多个store且同时保存在单一的状态树中

        vuex和单纯的全局对象有什么区别？ --1-- 20201209 17:07 --2- 17:27  --3-- 20201210 09:32  --4-- 20201210 20:14 --5-- 20201211 19:47
            --6-- 20201213 19:36
            vuex的状态存储是是响应式的
            当vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会得到高效更新
            不能直接更改store中的状态，只能通过mutation

        为什么vuex的mutation中不能做异步操作？ --1-- 20201209 17:22 --2-- 18:44 --3-- 20201210 09:34 --4-- 20201210 20:16 --5-- 20201211 19:48
            --6-- 20201213 19:36
            vuex中所有的状态更新的唯一途径都是mutation，异步操作通过action来提交实现。这样的话使得我们可以方便地跟踪每一个状态的变化，
            每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照，
            如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难

        vuex的action有返回值吗？返回的是什么？ --1-- 20201209 17:22 --2-- 18:44 --3--  20201210 09:36 --4-- 20201210 20:17 --5-- 20201211 19:48
        --6-- 20201213 19:38    
            
            store.dispatch可以处理被触发的action的处理函数返回的promise,并且store.dispatch仍旧返回promise
            一个store.dispatch在不同模块中可以触发多个action函数。在这种情况下，只有触发函数完成后，返回的promise才会执行。

        为什么不直接分发mutation,而要通过分发action之后提交mutation变更状态 --1-- 20201209 17:30 --3-- 20201210 09:42 --4-- 20201210 20:18 --5-- 20201211 19:49
        --6-- 20201213 19:43
        
        mutation必须同步执行，我们可以在action内部执行异步操作，并且通过提交mutation来记录状态变更

        computed和watch的区别和运用的场景？--1-- 20201209 23：43 --3-- 20201210 09:38 --4-- 20201210 20:18 --5-- 20201211 19:50
        --6-- 20201213 19:48    
            computed：是计算属性，依赖其他属性值，并且computed的值有缓存。
            只有它依赖的属性值发生改变，下一次获取computed的值时才会重新计算computed的值
            watch没有缓存性，每当监听的数据变化时都会执行回调进行后续操作
            数值计算并且依赖于其他数据时，应该使用computed，因为可以利用computed的缓存特性，避免每次获取值时，都要
            重新计算。
            当我们需要在数据变化时执行异步或开销较大的操作时，应该使用watch。
            使用watch选项允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。
            这些都是计算属性无法做到的

       vue2.x组件通信有哪些方式？ --1-- 20201209 11:50 --2-- 20201210 00:10 --3-- 20201210 09:42 --4-- 20201210 20:20 --5-- 20201211 19:51
       --6-- 20201213 19:53
       父子组件通信
               父对子  props 子对父 $on、$emit
               获取父子组件实例 $parent、$children 数组
               ref 获取实例的方法调用组件的属性或者方法
               provide、inject
          兄弟组件通信
               eventBus vuex
          跨级组件通信
               vuex $attrs $listeners provide inject

      说一下 v-if和v-show的区别？--1-- 20201209 11：58 --2-- 20201210 00:13 --3-- 20201210 09:53 --4-- 20201210 20:22 --5-- 20201211 19:52
          --6-- 20201213 19:54
          v-if不会渲染dom元素 v-show操作的是样式(display),切换当前DOM的显示和隐藏
          v-if用在很少改变条件，不需要频繁切换条件的场景，v-show则相反

      为什么v-for和v-if不建议用在一起  --1-- 20201210 00:07  --2-- 20201210  00:13 --3-- 20201210 09:53 --4-- 20201210 20:23 --5-- 20201211 19:53
          --6-- 20201213 19:54    
          当v-for 和 v-if 处于同一个节点时，v-for的优先级比v-if更高，这意味着v-if将分别重复运行于每个v-for循环中
          如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费。
          这种场景建议使用computed，先对数据进行过滤

 */
