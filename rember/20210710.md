### 继承的几种方式
第1次 ：2021-07-10 17:02 — 5分钟  1
第2次 ：2021-07-10 17:27 — 30分钟  1
第3次 ：2021-07-11 04:57 — 12小时
第4次 ：2021-07-11 16:57 — 1天
第5次 ：2021-07-12 16:57 — 2天
第6次 ：2021-07-14 16:57 — 4天
第7次 ：2021-07-17 16:57 — 7天
第8次 ：2021-07-25 16:57 — 15天
6种 原型链继承、借用构造函数继承、原型链+借用构造函数的组合继承 组合继承1 组合继承2 es6class的继承 extends
```JavaScript
function person(){
        }
        function student(){
            person.call(this, name, age)
        }
        student.prototype = Object.create(person.prototype)
        student.prototype.constructor = student;
```

### javascript对象的几种创建方式
第1次 ：2021-07-10 17:11 — 5分钟  1
第2次 ：2021-07-10 17:36 — 30分钟  1
第3次 ：2021-07-11 05:06 — 12小时
第4次 ：2021-07-11 17:06 — 1天
第5次 ：2021-07-12 17:06 — 2天
第6次 ：2021-07-14 17:06 — 4天
第7次 ：2021-07-17 17:06 — 7天
第8次 ：2021-07-25 17:06 — 15天
1.工厂模式
2.构造函数模式
3.原型模式
4.混合构造函数和原型模式
5.动态原型模式
6.寄生构造函数模式
7.稳妥构造函数模式

### 前端优化
第1次 ：2021-07-10 17:16 — 5分钟  1
第2次 ：2021-07-10 17:41 — 30分钟  1
第3次 ：2021-07-11 05:11 — 12小时
第4次 ：2021-07-11 17:11 — 1天
第5次 ：2021-07-12 17:11 — 2天
第6次 ：2021-07-14 17:11 — 4天
第7次 ：2021-07-17 17:11 — 7天
第8次 ：2021-07-25 17:11 — 15天
1. 减少http请求次数
2. css sprites js css 源码压缩、图片大小控制合适
3. CDN托管 data缓存
4. 前端用变量保存AJAX请求结果
5. 少用全局变量、缓存DOM节点查找的结果
6. 减少IO读取操作
7. 图片预加载
8. 将脚本放在底部 加上时间戳

### JavaScript性能优化
第1次 ：2021-07-10 17:21 — 5分钟  1
第2次 ：2021-07-10 17:46 — 30分钟  1
第3次 ：2021-07-11 05:16 — 12小时
第4次 ：2021-07-11 17:16 — 1天
第5次 ：2021-07-12 17:16 — 2天
第6次 ：2021-07-14 17:16 — 4天
第7次 ：2021-07-17 17:16 — 7天
第8次 ：2021-07-25 17:16 — 15天
1. 提升单单词脚本的执行速度，避免JavaScript的长任务霸占主线程，这样可以使得页面快速响应交互；
2. 避免大的内联脚本，因为在解析HTML的过程中，解析和编译也会占用主线程；
3. 减少JavaScript文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。

### 都做过哪些vue性能优化？
第1次 ：2021-07-10 17:30 — 5分钟  1
第2次 ：2021-07-10 17:55 — 30分钟
第3次 ：2021-07-11 05:25 — 12小时
第4次 ：2021-07-11 17:25 — 1天
第5次 ：2021-07-12 17:25 — 2天
第6次 ：2021-07-14 17:25 — 4天
第7次 ：2021-07-17 17:25 — 7天
第8次 ：2021-07-25 17:25 — 15天
1. 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher；
2. v-if和v-for不能连用；
3. 如果需要使用v-for给每项元素绑定事件时使用事件代理；
4. 在更多的情况下，使用v-if替代v-show
5. key保证唯一
6. 使用路由懒加载、异步组件
7. 防抖、节流
8. 第三方模块按需导入
9. 长列表滚动到可视区域动态加载；
10. 图片懒加载

### 其他优化
第1次 ：2021-07-10 17:33 — 5分钟    1
第2次 ：2021-07-10 17:58 — 30分钟
第3次 ：2021-07-11 05:28 — 12小时
第4次 ：2021-07-11 17:28 — 1天
第5次 ：2021-07-12 17:28 — 2天
第6次 ：2021-07-14 17:28 — 4天
第7次 ：2021-07-17 17:28 — 7天
第8次 ：2021-07-25 17:28 — 15天
1. SEO优化：预渲染；服务端渲染SSR
2. 打包优化：压缩代码、使用CDN加载第三方模块；多线程打包happypack，splitChunks抽离公共文件；sourceMap优化
3. 用户体验：骨架屏；PWA；还可以使用缓存，服务端开启GZIP压缩等；

### CDN的优化原理
第1次 ：2021-07-10 17:36 — 5分钟  1
第2次 ：2021-07-10 18:01 — 30分钟
第3次 ：2021-07-11 05:31 — 12小时
第4次 ：2021-07-11 17:31 — 1天
第5次 ：2021-07-12 17:31 — 2天
第6次 ：2021-07-14 17:31 — 4天
第7次 ：2021-07-17 17:31 — 7天
第8次 ：2021-07-25 17:31 — 15天
  内容分发网络
  工作原理就是将你源站的资源缓存到位于全球各地的CDN节点上，用户请求资源时，就近返回节点上缓存的资源，
  而不需要每个用户的请求都回到您的源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验

### V8是如何执行一段JavaScript代码的 
第1次 ：2021-07-10 17:42 — 5分钟  1
第2次 ：2021-07-10 18:07 — 30分钟
第3次 ：2021-07-11 05:37 — 12小时
第4次 ：2021-07-11 17:37 — 1天
第5次 ：2021-07-12 17:37 — 2天
第6次 ：2021-07-14 17:37 — 4天
第7次 ：2021-07-17 17:37 — 7天
第8次 ：2021-07-25 17:37 — 15天

1. 生成抽象语法树（AST)和执行上下文
   Babel的工作原理就是先将ES6源码转换为AST，然后再将es6语法的AST转换为ES5语法的AST，最后利用ES5的AST生成JavaScript源代码。

2. 生成字节码

3. 执行代码

### 消息队列和事件循环
第1次 ：2021-07-10 17:44 — 5分钟
第2次 ：2021-07-10 18:09 — 30分钟
第3次 ：2021-07-11 05:39 — 12小时
第4次 ：2021-07-11 17:39 — 1天
第5次 ：2021-07-12 17:39 — 2天
第6次 ：2021-07-14 17:39 — 4天
第7次 ：2021-07-17 17:39 — 7天
第8次 ：2021-07-25 17:39 — 15天

消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。

通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果DOM有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。

等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为DOM变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。

### 宏任务
页面中的大部分任务都是在主线程上执行的，这些任务包括了：
* 渲染事件（如解析DOM、计算布局、绘制）；
* 用户交互事件
* JavaScript脚本执行事件
* 网络请求完成、文件读写完成事件

为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个for循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。

整体代码script、setTimeout、setInterval、setImmediate

### 微任务

异步回调的概念，其主要有俩种方式。
第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。

第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。

微任务就是一个需要异步执行的函数，执行事件是在主函数执行结束之后、当前宏任务结束之前。

产生微任务有俩种方式：

第一种方式是使用MutationObserver监控某个DOM节点，然后再通过JavaScript来修改这个节点，或者为这个节点添加、删除部分子节点，当DOM节点发生变化时，就会产生DOM变化记录的微任务。

第二种方式是使用Promise，当调用Promise.resolve()或者Promise.reject()的时候，也会产生微任务。

通过DOM节点变化产生的微任务或者使用Promise产生的微任务都会被JavaScript引擎按照顺序来保存到微任务队列中

通常情况下，在当前宏任务中的JavaScript快执行完成时，也就在JavaScript引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。

如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8引擎一直循环执行微任务队列中的任务，知道队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。

原生promise中then方法、process.nextTick、MutationObserver

微任务先于宏任务执行 如果宏任务中有微任务 会先执行完微任务再执行宏任务

### DOM Tree是如何构建的？
转码：浏览器将接收到的二进制数据按照指定编码格式转化成HTML字符串
生成Tokens:之后开始parser，浏览器会将HTML字符串解析成Tokens
构建Nodes:对Node添加特定的属性，通过指针确定Node的父、子、兄弟关系和所属treeScope
生成DOM Tree:通过node包含的指针确定的关系构建出dom

### 什么是同源策略？
域名、协议、端口号相同

### 浏览器缓存
memory cache  指内存中的缓存 是响应速度最快的一种缓存 缺点是缓存时间短，关闭页面就不存在了
service worker cache 是一种独立于主线程之外的javascript线程。可以用来实现离线缓存、消息推送以及网络代理等功能
disk cache 硬盘缓存
push cache 推送缓存 是http2中的内容，仅存在于会话阶段

### osi7层
物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

### 常见的浏览器内核有哪些？
chrome blink webkit
firefox gecko
safari webkit
edge edgeHTML
IE trident
phantomJS webkit

### 缓存策略
强缓存
  强缓存是利用http头中的expires和cache-control俩个字段来控制的
  expires是一个时间戳、cache-control是一个时间长度
协商缓存
  协商缓存依赖于服务端与浏览器之间的通信
  last-modified和etag
  last-modified是一个时间戳
  etag是由服务器为每个资源生成的唯一标识字符串

### 如何实现跨域？
  jsonp
  cors
  nginx 反向代理
    所有的客户端的请求都必须经过nginx的处理，nginx作为代理服务器再将请求转发
  window.name
  document.domain 二级域名相同的情况下
  postMessage+iframe