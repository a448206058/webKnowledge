### 数据双向绑定单向绑定优缺点
第1次 ：2021-07-20 10:59 — 5分钟  1
第2次 ：2021-07-20 11:24 — 30分钟  1
第3次 ：2021-07-20 22:54 — 12小时
第4次 ：2021-07-21 10:54 — 1天
第5次 ：2021-07-22 10:54 — 2天
第6次 ：2021-07-24 10:54 — 4天
第7次 ：2021-07-27 10:54 — 7天
第8次 ：2021-08-04 10:54 — 15天

* 双向绑定是⾃动管理状态的，对处理有⽤户交互的场景⾮常合适，代码量少，当项⽬越来越⼤的时
候，调试也变得越来越复杂，难以跟踪问题

* 单向绑定是⽆状态的, 程序调试相对容易, 可以避免程序复杂度上升时产⽣的各种问题, 当然写代码
时就没有双向绑定那么爽了

### React fiber 的理解和原理
第1次 ：2021-07-20 11:02 — 5分钟  1
第2次 ：2021-07-20 11:27 — 30分钟  1
第3次 ：2021-07-20 22:57 — 12小时  1
第4次 ：2021-07-21 10:57 — 1天
第5次 ：2021-07-22 10:57 — 2天
第6次 ：2021-07-24 10:57 — 4天
第7次 ：2021-07-27 10:57 — 7天
第8次 ：2021-08-04 10:57 — 15天

React16 以前
React16 以前，对virtural dom的更新和渲染是同步的。就是当⼀次更新或者⼀次加载开始以后，diff
virtual dom并且渲染的过程是⼀⼝⽓完成的。如果组件层级⽐较深，相应的堆栈也会很深，⻓时间占⽤
浏览器主线程，⼀些类似⽤户输⼊、⿏标滚动等操作得不到响应。借Lin的两张图，视频 A Cartoon
Intro to Fiber - React Conf 2017。
function traversal(node) {
 //对node的处理
 if (node && node.nodeType === 1) {
 console.log(node.tagName);
 }
 var i = 0,
 childNodes = node.childNodes,
 item;
 for (; i < childNodes.length; i++) {
 item = childNodes[i];
 if (item.nodeType === 1) {
 //递归先序遍历⼦节点
 traversal(item);
 }
 }
}React16 Fiber Reconciler
React16 ⽤了分⽚的⽅式解决上⾯的问题。
就是把⼀个任务分成很多⼩⽚，当分配给这个⼩⽚的时间⽤尽的时候，就检查任务列表中有没有新的、
优先级更⾼的任务，有就做这个新任务，没有就继续做原来的任务。这种⽅式被叫做异步渲染(Async
Rendering)。
⼀些原理
Fiber就是通过对象记录组件上需要做或者已经完成的更新，⼀个组件可以对应多个Fiber。
在render函数中创建的React Element树在第⼀次渲染的时候会创建⼀颗结构⼀模⼀样的Fiber节点树。
不同的React Element类型对应不同的Fiber节点类型。⼀个React Element的⼯作就由它对应的Fiber节
点来负责。
⼀个React Element可以对应不⽌⼀个Fiber，因为Fiber在update的时候，会从原来的Fiber（我们称为
current）clone出⼀个新的Fiber（我们称为alternate）。两个Fiber diff出的变化（side effect）记录
在alternate上。所以⼀个组件在更新时最多会有两个Fiber与其对应，在更新结束后alternate会取代之
前的current的成为新的current节点。
其次，Fiber的基本规则：
更新任务分成两个阶段，Reconciliation Phase和Commit Phase。Reconciliation Phase的任务⼲的事
情是，找出要做的更新⼯作（Diff Fiber Tree），就是⼀个计算阶段，计算结果可以被缓存，也就可以
被打断；Commmit Phase 需要提交所有更新并渲染，为了防⽌⻚⾯抖动，被设置为不能被打断。
PS: componentWillMount componentWillReceiveProps componentWillUpdate ⼏个⽣命周期⽅法，
在Reconciliation Phase被调⽤，有被打断的可能（时间⽤尽等情况），所以可能被多次调⽤。其实
shouldComponentUpdate 也可能被多次调⽤，只是它只返回true或者false，没有副作⽤，可以暂时
忽略。

### 调⽤ setState 之后发⽣了什么？
第1次 ：2021-07-20 11:11 — 5分钟  1
第2次 ：2021-07-20 11:36 — 30分钟   1
第3次 ：2021-07-20 23:06 — 12小时
第4次 ：2021-07-21 11:06 — 1天
第5次 ：2021-07-22 11:06 — 2天
第6次 ：2021-07-24 11:06 — 4天
第7次 ：2021-07-27 11:06 — 7天
第8次 ：2021-08-04 11:06 — 15天

* 在代码中调⽤ setState 函数之后，React 会将传⼊的参数对象与组件当前的状态合并，然后触发
所谓的调和过程。

* 经过调和过程，React会以相对⾼效的⽅式根据新的状态构建React元素树并且着⼿重新渲染整个
UI 界⾯。

* 在 React 得到元素树之后，React 会⾃动计算出新的树与⽼树的节点差异，然后根据差异对界⾯进
⾏最⼩化重渲染。

* 在差异计算算法中，React 能够相对精确地知道哪些位置发⽣了改变以及应该如何改变，这就保证
了按需更新，⽽不是全部重新渲染

### 触发多次setstate，那么render会执⾏⼏次？
第1次 ：2021-07-20 11:18 — 5分钟  1
第2次 ：2021-07-20 11:43 — 30分钟  1
第3次 ：2021-07-20 23:13 — 12小时
第4次 ：2021-07-21 11:13 — 1天
第5次 ：2021-07-22 11:13 — 2天
第6次 ：2021-07-24 11:13 — 4天
第7次 ：2021-07-27 11:13 — 7天
第8次 ：2021-08-04 11:13 — 15天

* 多次setState会合并为⼀次render，因为setState并不会⽴即改变state的值，⽽是将其放到⼀个任
务队列⾥，最终将多个setState合并，⼀次性更新⻚⾯。

* 所以我们可以在代码⾥多次调⽤setState，每次只需要关注当前修改的字段即可

### react中如何对state中的数据进⾏修改？setState为什么是⼀个异步的？
第1次 ：2021-07-20 11:19 — 5分钟  1
第2次 ：2021-07-20 11:44 — 30分钟  1
第3次 ：2021-07-20 23:14 — 12小时
第4次 ：2021-07-21 11:14 — 1天
第5次 ：2021-07-22 11:14 — 2天
第6次 ：2021-07-24 11:14 — 4天
第7次 ：2021-07-27 11:14 — 7天
第8次 ：2021-08-04 11:14 — 15天

* 修改数据通过this.setState(参数1,参数2)

* this.setState是⼀个异步函数
参数1 : 是需要修改的数据是⼀个对象
参数2 : 是⼀个回调函数，可以⽤来验证数据是否修改成功，同时可以获取到数据更新后的
DOM结构等同于componentDidMount

* this.setState中的第⼀个参数除了可以写成⼀个对象以外，还可以写成⼀个函数 ！，函数中第⼀
个值为prevState 第⼆个值为prePprops this.setState((prevState,prop)=>({}))

### 为什么建议传递给 setState的参数是⼀个callback⽽不是⼀个对象？
第1次 ：2021-07-20 11:21 — 5分钟  1
第2次 ：2021-07-20 11:46 — 30分钟  1
第3次 ：2021-07-20 23:16 — 12小时
第4次 ：2021-07-21 11:16 — 1天
第5次 ：2021-07-22 11:16 — 2天
第6次 ：2021-07-24 11:16 — 4天
第7次 ：2021-07-27 11:16 — 7天
第8次 ：2021-08-04 11:16 — 15天

* 因为this.props 和this.state的更新可能是异步的，不能依赖它们的值去计算下⼀个state

### 为什么setState是⼀个异步的？
第1次 ：2021-07-20 11:22 — 5分钟  1
第2次 ：2021-07-20 11:47 — 30分钟  1
第3次 ：2021-07-20 23:17 — 12小时
第4次 ：2021-07-21 11:17 — 1天
第5次 ：2021-07-22 11:17 — 2天
第6次 ：2021-07-24 11:17 — 4天
第7次 ：2021-07-27 11:17 — 7天
第8次 ：2021-08-04 11:17 — 15天
* 当批量执⾏state的时候可以让DOM渲染的更快,也就是说多个setstate在执⾏的过程中还需要被合
并

### 原⽣事件和React事件的区别？
第1次 ：2021-07-20 11:29 — 5分钟  1
第2次 ：2021-07-20 11:54 — 30分钟  1
第3次 ：2021-07-20 23:24 — 12小时
第4次 ：2021-07-21 11:24 — 1天
第5次 ：2021-07-22 11:24 — 2天
第6次 ：2021-07-24 11:24 — 4天
第7次 ：2021-07-27 11:24 — 7天
第8次 ：2021-08-04 11:24 — 15天

* React 事件使⽤驼峰命名，⽽不是全部⼩写。

* 通过 JSX , 你传递⼀个函数作为事件处理程序，⽽不是⼀个字符串。

* 在 React 中你不能通过返回 false 来阻⽌默认⾏为。必须明确调⽤ preventDefault 。

### React的合成事件是什么？
第1次 ：2021-07-20 11:38 — 5分钟  1
第2次 ：2021-07-20 12:03 — 30分钟  1
第3次 ：2021-07-20 23:33 — 12小时
第4次 ：2021-07-21 11:33 — 1天
第5次 ：2021-07-22 11:33 — 2天
第6次 ：2021-07-24 11:33 — 4天
第7次 ：2021-07-27 11:33 — 7天
第8次 ：2021-08-04 11:33 — 15天

React 根据 W3C 规范定义了每个事件处理函数的参数，即合成事件。

事件处理程序将传递 SyntheticEvent 的实例，这是⼀个跨浏览器原⽣事件包装器。它具有与浏览器
原⽣事件相同的接⼝，包括 stopPropagation() 和 preventDefault() ，在所有浏览器中他们⼯作
⽅式都相同。

React 合成的 SyntheticEvent 采⽤了事件池，这样做可以⼤⼤节省内存，⽽不会频繁的创建和销毁
事件对象。

另外，不管在什么浏览器环境下，浏览器会将该事件类型统⼀创建为合成事件，从⽽达到了浏览器兼容
的⽬的。

### 什么是⾼阶组件（HOC）？
第1次 ：2021-07-20 11:40 — 5分钟  1
第2次 ：2021-07-20 12:05 — 30分钟  1
第3次 ：2021-07-20 23:35 — 12小时
第4次 ：2021-07-21 11:35 — 1天
第5次 ：2021-07-22 11:35 — 2天
第6次 ：2021-07-24 11:35 — 4天
第7次 ：2021-07-27 11:35 — 7天
第8次 ：2021-08-04 11:35 — 15天

⾼阶组件是重⽤组件逻辑的⾼级⽅法，是⼀种源于 React 的组件模式。 HOC 是⾃定义组件，在它之内
包含另⼀个组件。它们可以接受⼦组件提供的任何动态，但不会修改或复制其输⼊组件中的任何⾏为。
你可以认为 HOC 是“纯（Pure）”组件。

### 你能⽤HOC做什么？
第1次 ：2021-07-20 11:53 — 5分钟
第2次 ：2021-07-20 12:18 — 30分钟
第3次 ：2021-07-20 23:48 — 12小时
第4次 ：2021-07-21 11:48 — 1天
第5次 ：2021-07-22 11:48 — 2天
第6次 ：2021-07-24 11:48 — 4天
第7次 ：2021-07-27 11:48 — 7天
第8次 ：2021-08-04 11:48 — 15天

HOC可⽤于许多任务，例如：
* 代码重⽤，逻辑和引导抽象
* 渲染劫持
* 状态抽象和控制
* Props 控制

### vue3比vue2有什么优势？
第1次 ：2021-07-20 15:34 — 5分钟  1
第2次 ：2021-07-20 15:59 — 30分钟
第3次 ：2021-07-21 03:29 — 12小时
第4次 ：2021-07-21 15:29 — 1天
第5次 ：2021-07-22 15:29 — 2天
第6次 ：2021-07-24 15:29 — 4天
第7次 ：2021-07-27 15:29 — 7天
第8次 ：2021-08-04 15:29 — 15天

* 性能更好
* 体积更小
* 更好的ts支持
* 更好的代码组织
* 更好的逻辑抽离
* 更多新功能

### 描述 vue3生命周期
* Options API生命周期
    * beforeDestroy 改为 beforeUnmount
    * destroyed改为unmounted
    * 其他沿用vue2生命周期

* Composition API生命周期

### 如何看待 Composition API 和 Options API?
* Composition API带来了什么？
第1次 ：2021-07-20 15:35 — 5分钟  1
第2次 ：2021-07-20 16:00 — 30分钟
第3次 ：2021-07-21 03:30 — 12小时
第4次 ：2021-07-21 15:30 — 1天
第5次 ：2021-07-22 15:30 — 2天
第6次 ：2021-07-24 15:30 — 4天
第7次 ：2021-07-27 15:30 — 7天
第8次 ：2021-08-04 15:30 — 15天
    * 更好的代码组织
    * 更好的逻辑复用
    * 更好的类型推导

* Composition API和OptionAPI如何选择？
第1次 ：2021-07-20 15:36 — 5分钟  1
第2次 ：2021-07-20 16:01 — 30分钟
第3次 ：2021-07-21 03:31 — 12小时
第4次 ：2021-07-21 15:31 — 1天
第5次 ：2021-07-22 15:31 — 2天
第6次 ：2021-07-24 15:31 — 4天
第7次 ：2021-07-27 15:31 — 7天
第8次 ：2021-08-04 15:31 — 15天
    * 不要复用
    * 简单的用option api
    * 复杂的用composition api

* 不要误解compostion api
    * Composition API属于高阶技巧，不是基础必会
    * Composition API是为解决复杂业务逻辑而设计
    * Composition API就像Hooks在React中的地位

### 如何理解 ref toRef和toRefs?
* 是什么
    ref
    第1次 ：2021-07-20 15:40 — 5分钟
第2次 ：2021-07-20 16:05 — 30分钟
第3次 ：2021-07-21 03:35 — 12小时
第4次 ：2021-07-21 15:35 — 1天
第5次 ：2021-07-22 15:35 — 2天
第6次 ：2021-07-24 15:35 — 4天
第7次 ：2021-07-27 15:35 — 7天
第8次 ：2021-08-04 15:35 — 15天
        * 生成值类型的响应式数据
        * 可用于模版和reactive
        * 通过.value修改值

    toRef
        * 针对一个响应式对象（reactive封装)的prop
        * 创建一个ref，具有响应式
        * 俩者保持引用关系
        

* 最佳使用方式
* 进阶，深入理解  