* 最佳使用方式
第1次 ：2021-07-21 11:01 — 5分钟  1
第2次 ：2021-07-21 11:26 — 30分钟  1
第3次 ：2021-07-21 22:56 — 12小时  1
第4次 ：2021-07-22 10:56 — 1天  1
第5次 ：2021-07-23 10:56 — 2天
第6次 ：2021-07-25 10:56 — 4天
第7次 ：2021-07-28 10:56 — 7天
第8次 ：2021-08-05 10:56 — 15天

    * 用reactive做对象的响应式，用ref做值类型响应式
    * setup中返回toRefs(state)，或者toRef(state, 'xxx')
    * ref的变量命名都用xxxRef
    * 合成函数返回响应式对象时，使用toRefs

* 进阶，深入理解  
* 为何需要ref?
第1次 ：2021-07-21 11:05 — 5分钟  1
第2次 ：2021-07-21 11:30 — 30分钟  1
第3次 ：2021-07-21 23:00 — 12小时  1
第4次 ：2021-07-22 11:00 — 1天
第5次 ：2021-07-23 11:00 — 2天
第6次 ：2021-07-25 11:00 — 4天
第7次 ：2021-07-28 11:00 — 7天
第8次 ：2021-08-05 11:00 — 15天

    * 返回值类型，会丢失响应式
    * 如在setup、computed、合成函数，都有可能返回值类型
    * Vue如不定义ref，用户将自造ref,反而混乱

* 为何需要.value?
第1次 ：2021-07-21 11:08 — 5分钟  1
第2次 ：2021-07-21 11:33 — 30分钟  1
第3次 ：2021-07-21 23:03 — 12小时  1
第4次 ：2021-07-22 11:03 — 1天
第5次 ：2021-07-23 11:03 — 2天
第6次 ：2021-07-25 11:03 — 4天
第7次 ：2021-07-28 11:03 — 7天
第8次 ：2021-08-05 11:03 — 15天

    * ref是一个对象（不丢失响应式），value存储值
    * 通过.value属性的get和set实现响应式
    * 用于模版、reactive时，不需要.value，其他情况都需要

* 为何需要toRef toRefs?
第1次 ：2021-07-21 11:10 — 5分钟  1
第2次 ：2021-07-21 11:35 — 30分钟  1
第3次 ：2021-07-21 23:05 — 12小时  1
第4次 ：2021-07-22 11:05 — 1天
第5次 ：2021-07-23 11:05 — 2天
第6次 ：2021-07-25 11:05 — 4天
第7次 ：2021-07-28 11:05 — 7天
第8次 ：2021-08-05 11:05 — 15天

    * 初衷：不丢失响应式的情况下，把对象数据 分解/扩散
    * 前提：针对的是响应式对象（reactive封装的）非普通对象
    * 注意：不创造响应式，而是延续响应式

### Vue3升级类哪些重要的功能？
第1次 ：2021-07-21 11:16 — 5分钟  1
第2次 ：2021-07-21 11:41 — 30分钟  1
第3次 ：2021-07-21 23:11 — 12小时  1
第4次 ：2021-07-22 11:11 — 1天  1
第5次 ：2021-07-23 11:11 — 2天
第6次 ：2021-07-25 11:11 — 4天
第7次 ：2021-07-28 11:11 — 7天
第8次 ：2021-08-05 11:11 — 15天
    * createApp
    * emits属性
    * 生命周期
    * 多事件
    * Fragment
    * 移除.sync
    * 异步组件的写法
    * 移除filter
    * Teleport
    * Suspense
    * Composition API

### Composition API如何实现代码逻辑复用？
第1次 ：2021-07-21 11:17 — 5分钟  1
第2次 ：2021-07-21 11:42 — 30分钟   1
第3次 ：2021-07-21 23:12 — 12小时  1
第4次 ：2021-07-22 11:12 — 1天
第5次 ：2021-07-23 11:12 — 2天
第6次 ：2021-07-25 11:12 — 4天
第7次 ：2021-07-28 11:12 — 7天
第8次 ：2021-08-05 11:12 — 15天

* 抽离逻辑代码到一个函数
* 函数命名约定为useXxxx格式（React Hooks也是）
* 在setup中引用usexxx函数


 * 算法分类：
 *      常见排序算法可以分为俩大类：
 *          比较类排序： 通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn),因此也成为非线性时间比较类排序。
 *              交换排序：
 *                  冒泡排序    O(n2)       O(1)
 *                  快速排序    O(nlog2n)   O(nlog2n)
 *              插入排序
 *                  简单插入排序   O(n2)  O(1)
 *                  希尔排序    O(n2)   O(1)
 *              选择排序
 *                  简单选择排序  O(n2)   O(1)
 *                  堆排序     O(nlog2n)   O(1)
 *              归并排序
 *                  二路归并排序  O(nlog2n)   O(n)
 *                  多路归并排序  O(nlog2n)   O(n)
 *
 *          非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。
 *              计数排序    O(n+k)      O(n+k)
 *              桶排序     O(n+k)      O(n+k)
 *              基数排序    O(n*k)      O(n+k)
 


 *  冒泡排序：   O(n2)
 *      比较相邻的元素。如果第一个比第二个大，就交换它们俩个；
 *      对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该回收最大的数；
 *      针对所有元素重复以上的步骤，除了最后一个；
 *      重复1-3，直到排序完成。
第1次 ：2021-07-21 11:26 — 5分钟  1
第2次 ：2021-07-21 11:51 — 30分钟  1
第3次 ：2021-07-21 23:21 — 12小时
第4次 ：2021-07-22 11:21 — 1天
第5次 ：2021-07-23 11:21 — 2天
第6次 ：2021-07-25 11:21 — 4天
第7次 ：2021-07-28 11:21 — 7天
第8次 ：2021-08-05 11:21 — 15天
```JavaScript
function bubbleSort (arr) {
    // i [1, n]
    let n = arr.length;
    while (n > 1) {
        for (let i = 1; i < n; i++) {
            if (arr[i - 1] > arr[i]) {
                let temp = arr[i - 1];
                arr[i - 1] = arr[i];
                arr[i] = temp;
            }
        }
        n--;
    }
    return arr;
}
```

 * 选择排序：    O(n2)
 *      首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。

第1次 ：2021-07-21 11:38 — 5分钟  1
第2次 ：2021-07-21 12:03 — 30分钟  1
第3次 ：2021-07-21 23:33 — 12小时   1
第4次 ：2021-07-22 11:33 — 1天
第5次 ：2021-07-23 11:33 — 2天
第6次 ：2021-07-25 11:33 — 4天
第7次 ：2021-07-28 11:33 — 7天
第8次 ：2021-08-05 11:33 — 15天

```JavaScript
function selectionSort (arr) {
    let n = 0;
    while (n < arr.length) {
        let c = n;
        for (let i = n; i < arr.length; i++) {
            if (arr[i] < arr[c]) {
                c = i;
            }
        }
        let temp = arr[n];
        arr[n] = arr[c];
        arr[c] = temp;
        n++;
    }
    return arr
}
```