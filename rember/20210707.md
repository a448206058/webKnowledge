### 闭包

定义：函数A返回了一个函数B，并且函数B中使用了函数A的变量，函数B就被称为闭包


### this
第1次 ：2021-07-07 10:12 — 5分钟   1
第2次 ：2021-07-07 10:37 — 30分钟  1
第3次 ：2021-07-07 22:07 — 12小时  1
第4次 ：2021-07-08 10:07 — 1天
第5次 ：2021-07-09 10:07 — 2天
第6次 ：2021-07-11 10:07 — 4天
第7次 ：2021-07-14 10:07 — 7天
第8次 ：2021-07-22 10:07 — 15天

this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象。
函数的调用方式决定了 this 的值（运行时绑定）。

1）函数执行，看方法前面是否有“点”，没有“点”，this是window「严格模式下是undefined」，有“点”，“点”前面是谁this就是谁

2）给当前元素的某个事件行为绑定方法，当事件行为触发，方法中的this是当前元素本身「排除attachEvent」

3）构造函数体中的this是当前类的实例。

4）箭头函数中没有执行主体，所用到的this都是其所处上下文中的this。

5）可以基于Function.prototype上的call/apply/bind去改变this指向。

### map、flatMap、reduce
第1次 ：2021-07-07 10:49 — 5分钟  1
第2次 ：2021-07-07 11:14 — 30分钟  1
第3次 ：2021-07-07 22:44 — 12小时  1
第4次 ：2021-07-08 10:44 — 1天
第5次 ：2021-07-09 10:44 — 2天
第6次 ：2021-07-11 10:44 — 4天
第7次 ：2021-07-14 10:44 — 7天
第8次 ：2021-07-22 10:44 — 15天
map的作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后append到新的数组中
map有三个参数，分别是当前索引元素，索引，原数组

flatMap和map的作用几乎是相同的，但是对于多为数组来说，会将原数组降维。可以将FlatMap看成是map + flatten，目前该函数在浏览器中还不支持。

reduce作用是数组中的值组合起来，最终得到一个值

```JavaScript
const flattenDeep = (arr) => Array.isArray(arr) ? arr.reduce( (a, b) => [...a, ...flattenDeep(b)], []) : [arr]
```

### async await
第1次 ：2021-07-07 11:30 — 5分钟  1
第2次 ：2021-07-07 11:55 — 30分钟 1
第3次 ：2021-07-07 23:25 — 12小时  1
第4次 ：2021-07-08 11:25 — 1天
第5次 ：2021-07-09 11:25 — 2天
第6次 ：2021-07-11 11:25 — 4天
第7次 ：2021-07-14 11:25 — 7天
第8次 ：2021-07-22 11:25 — 15天
async 函数
函数的返回值为promise对象，promise对象的结果由async函数执行的返回值决定。如果任何一个await语句后面的promise对象变为reject状态或遇到return,那么整个async函数都会中断执行

await 表达式
如果表达式是promise对象，await返回的是promise成功的值；如果表达式是其他值，直接就讲此值作为await的返回值。

### JS的异步处理函数有哪些
第1次 ：2021-07-07 11:28 — 5分钟  1
第2次 ：2021-07-07 11:53 — 30分钟  1
第3次 ：2021-07-07 23:23 — 12小时  1
第4次 ：2021-07-08 11:23 — 1天
第5次 ：2021-07-09 11:23 — 2天
第6次 ：2021-07-11 11:23 — 4天
第7次 ：2021-07-14 11:23 — 7天
第8次 ：2021-07-22 11:23 — 15天
promise对象

generator函数

async函数

回调函数

事件监听

发布订阅模式

### 类型转换
第1次 ：2021-07-07 11:36 — 5分钟  1
第2次 ：2021-07-07 12:01 — 30分钟 1
第3次 ：2021-07-07 23:31 — 12小时 1
第4次 ：2021-07-08 11:31 — 1天
第5次 ：2021-07-09 11:31 — 2天
第6次 ：2021-07-11 11:31 — 4天
第7次 ：2021-07-14 11:31 — 7天
第8次 ：2021-07-22 11:31 — 15天
显示转换
Number()、parseInt()、String()、Boolean()

隐式转换
比较运算
算术运算

### 函数函数柯里化
第1次 ：2021-07-07 11:49 — 5分钟  1
第2次 ：2021-07-07 12:14 — 30分钟
第3次 ：2021-07-07 23:44 — 12小时  1
第4次 ：2021-07-08 11:44 — 1天
第5次 ：2021-07-09 11:44 — 2天
第6次 ：2021-07-11 11:44 — 4天
第7次 ：2021-07-14 11:44 — 7天
第8次 ：2021-07-22 11:44 — 15天
//在计算机科学中，柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回
//接受余下的参数且返回结果的新函数的技术。
//函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行

```JavaScript
function curry(fn, curryArgs){
    var args = [].slice.call(arguments);

    if(curryArgs !== undefined){
        args = args.concat(curryArgs);
    }
    if(args.length < fn.length){
        return curry(fn, args);
    }
    return fn.apply(null, args);
}
```

### v-show 和 v-if 的区别


### 为何在v-for中用key

### 描述vue组件生命周期
* 单组件生命周期图
* 父子组件生命周期关系

### vue组件如何通讯
* 父子组件props和this.$emit
* 自定义事件event.$no event.$off event.$emit
* vuex

### 双向数据绑定 v-model的实现原理
* input元素的 value = this.name
* 绑定input事件this.name = $event.target.value
* data更新触发re-render

### MVVM的理解
view  viewmodel(dom listener directives)  model

### computed 有何特点
* 缓存，data不变不会重新计算
* 提高性能

### 为何组件data必须是一个函数？

### ajax请求应该放在哪个生命周期
* mounted
* JS是单线程的，ajax异步获取数据
* 放在mounted之前没有用，只会让逻辑更加混乱

### 如何将组件所有props传递给子组件？
* $props
* <User v-bind="$props" />

### 如何自己实现v-model
```
<input type="text" :value="text" @input="$emit('change', $event.target.value)">
```

### 多个组件有相同的逻辑，如何抽离？
* mixin

### 何时要使用异步组件？

### 何时需要使用keep-alive?
* 缓存组件，不需要重复渲染
* 如多个静态tab页的切换
* 优化性能

### 何时需要使用beforeDestory
* 解绑自定义事件event.$off
* 清除定时器
* 解绑自定义的DOM事件，如window scroll等

### 什么是作用域插槽

### vuex中avtion和mutation有何区别
* action中处理异步，mutation不可以
* mutation做原子操作

### vue-router常用的路由模式
* hash
* h5 history
* 俩者比较

### 如何配置vue-router异步加载

### 请用vnode描述一个DOM
```
{
    tag: '',
    props: {
        className
    }
    },
    children: [

    ]
}
```
### 监听data变化的核心API是什么
* Object.defineProperty
* 以及深度监听、监听数组
* 有何缺点

### vue如何监听数组变化
* Object.defineProperty不能监听数组变化
* 重新定义原型，重写push pop等方法，实现监听
* proxy可以原生支持监听数组变化

### 请描述响应式原理
* 监听data变化
* 组件渲染和更新的流程

### diff算法的时间复杂度
* O(n)
* 在O(n^3)上做的优化

### 简述diff算法过程
* patch(elem, vnode)和patch(vnode, newVnode)
* patchVnode和addVnodes和removeVnodes
* updateChildren(key的重要性)

### vue为何是异步渲染，$nextTick何用？
* 异步渲染（以及合并data修改），以提高渲染性能
* $nextTick在DOM更新完之后，触发回调

### vue常见性能优化方式
* 合理使用v-show和v-if
* 合理使用computed
* v-for时加key,以及避免和v-if同时使用
* 自定义事件、DOM事件及时销毁
* 合理使用异步组件
* 合理使用keep-alive
* data层级不要太深
* 使用vue-loader在开发环境做模版编译（预编译）
* webpack层面的优化
* 前端通用的性能优化，如图片懒加载
* 使用SSR