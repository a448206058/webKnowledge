### 原型链    
第1次 ：2021-07-02 09:14 — 5分钟  1
第2次 ：2021-07-02 09:39 — 30分钟  1
第3次 ：2021-07-02 21:09 — 12小时
第4次 ：2021-07-03 09:09 — 1天
第5次 ：2021-07-04 09:09 — 2天
第6次 ：2021-07-06 09:09 — 4天
第7次 ：2021-07-09 09:09 — 7天
第8次 ：2021-07-17 09:09 — 15天

如果原型是另一个类型的实例。就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。

### new
第1次 ：2021-07-02 09:31 — 5分钟    1
第2次 ：2021-07-02 09:56 — 30分钟   1
第3次 ：2021-07-02 21:26 — 12小时
第4次 ：2021-07-03 09:26 — 1天
第5次 ：2021-07-04 09:26 — 2天
第6次 ：2021-07-06 09:26 — 4天
第7次 ：2021-07-09 09:26 — 7天
第8次 ：2021-07-17 09:26 — 15天

1. 新生成了一个对象
2. 链接到原型
3. 绑定this
4. 返回新对象

```JavaScript
function create() {
  // 创建一个空的对象
  let obj = new Object()
  // 获得构造函数
  let Con = [].shift.call(argument);
  // 链接到原型
  obj.__proto__ = Con.prototype
  // 绑定this,执行构造函数
  let result = Con.apply(obj, arguments)
  // 确保new出来的是个对象
  return typeof result === 'object'  result : obj
}
```

### instanceof
第1次 ：2021-07-02 09:51 — 5分钟  1
第2次 ：2021-07-02 10:16 — 30分钟  1
第3次 ：2021-07-02 21:46 — 12小时
第4次 ：2021-07-03 09:46 — 1天
第5次 ：2021-07-04 09:46 — 2天
第6次 ：2021-07-06 09:46 — 4天
第7次 ：2021-07-09 09:46 — 7天
第8次 ：2021-07-17 09:46 — 15天

instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的prototype
```JavaScript
function instanceof(left, right) {
  // 获得类型的原型
  let prototype = right.prototype
  // 获得对象的原型
  left = left.__proto__
  // 判断对象的类型是否等于类型的原型
  while (true) {
    if (left === null)
      return false
    if (prototype === left)
      return true
    left = left.__proto__
  }
}

```

### this
第1次 ：2021-07-02 10:11 — 5分钟       1
第2次 ：2021-07-02 10:36 — 30分钟      1
第3次 ：2021-07-02 22:06 — 12小时
第4次 ：2021-07-03 10:06 — 1天
第5次 ：2021-07-04 10:06 — 2天
第6次 ：2021-07-06 10:06 — 4天
第7次 ：2021-07-09 10:06 — 7天
第8次 ：2021-07-17 10:06 — 15天

this 只依赖于调用函数前的对象
```JavaScript
function foo() {
	console.log(this.a)
}
var a = 1
foo()

var obj = {
	a: 2,
	foo: foo
}
obj.foo()

// 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况

// 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向
var c = new foo()
c.a = 3
console.log(c.a)

// 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new
```

### 执行上下文
第1次 ：2021-07-02 10:31 — 5分钟  1
第2次 ：2021-07-02 10:56 — 30分钟  1
第3次 ：2021-07-02 22:26 — 12小时
第4次 ：2021-07-03 10:26 — 1天
第5次 ：2021-07-04 10:26 — 2天
第6次 ：2021-07-06 10:26 — 4天
第7次 ：2021-07-09 10:26 — 7天
第8次 ：2021-07-17 10:26 — 15天

当执行JS代码时，会产生三种执行上下文
* 全局执行上下文
* 函数执行上下文
* eval执行上下文

每个执行上下文中都有三个重要的属性

* 变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问
* 作用域链
* this

对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过[[Scope]]属性查找上级变量

在生成执行上下文时，会有俩个阶段。第一个阶段是创建的阶段，JS解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。

在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升

### 闭包
第1次 ：2021-07-02 10:58 — 5分钟
第2次 ：2021-07-02 11:23 — 30分钟
第3次 ：2021-07-02 22:53 — 12小时
第4次 ：2021-07-03 10:53 — 1天
第5次 ：2021-07-04 10:53 — 2天
第6次 ：2021-07-06 10:53 — 4天
第7次 ：2021-07-09 10:53 — 7天
第8次 ：2021-07-17 10:53 — 15天

定义：函数A返回了一个函数B，并且函数B中使用了函数A的变量，函数B就被称为闭包