### 什么是闭包？
第1次 ：2021-07-09 11:07 — 5分钟  1
第2次 ：2021-07-09 11:32 — 30分钟  1
第3次 ：2021-07-09 23:02 — 12小时  1
第4次 ：2021-07-10 11:02 — 1天  1
第5次 ：2021-07-11 11:02 — 2天  1
第6次 ：2021-07-13 11:02 — 4天
第7次 ：2021-07-16 11:02 — 7天
第8次 ：2021-07-24 11:02 — 15天

能够读取其它函数内部变量的函数，就是闭包
作用：
    1.从外部读取函数内部的变量
    2.将创建的变量的值始终保持在内存中
    3.封装对象的私有属性和私有方法

### 为什么很多站点第二次打开速度会很快？
第1次 ：2021-07-09 11:08 — 5分钟  1
第2次 ：2021-07-09 11:33 — 30分钟  1
第3次 ：2021-07-09 23:03 — 12小时  1
第4次 ：2021-07-10 11:03 — 1天   1
第5次 ：2021-07-11 11:03 — 2天  1
第6次 ：2021-07-13 11:03 — 4天
第7次 ：2021-07-16 11:03 — 7天
第8次 ：2021-07-24 11:03 — 15天

DNS缓存和页面资源缓存
因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS数据也被浏览器缓存了，这又省去了DNS查询环节。

### 浏览器输入一个地址。到页面展示中间经历了哪些东西？
第1次 ：2021-07-09 11:19 — 5分钟  1
第2次 ：2021-07-09 11:44 — 30分钟  1
第3次 ：2021-07-09 23:14 — 12小时  1
第4次 ：2021-07-10 11:14 — 1天   1
第5次 ：2021-07-11 11:14 — 2天  1
第6次 ：2021-07-13 11:14 — 4天
第7次 ：2021-07-16 11:14 — 7天
第8次 ：2021-07-24 11:14 — 15天
1.浏览器检查地址是否合法
2.查看是否有缓存，如果有缓存，则读取缓存
3.在发起http请求前，进行dns解析，即域名解析出对应的IP地址
4.浏览器向服务器发起TCP连接，经历三次握手
5.客户端向服务端发起请求，请求数据包
6.服务端接受到请求，将数据返回浏览器
7.客户端收到http响应
8.浏览器解析响应。如果响应可以缓存，则存入缓存
9.浏览器发送请求获取嵌入在HTML中的资源
10.浏览器发送异步请求
11.页面全部渲染结束

### 渲染流程：HTML、CSS和JavaScript是如何变成页面的？
第1次 ：2021-07-09 11:44 — 5分钟  1
第2次 ：2021-07-09 12:09 — 30分钟  1
第3次 ：2021-07-09 23:39 — 12小时  1
第4次 ：2021-07-10 11:39 — 1天   1
第5次 ：2021-07-11 11:39 — 2天   1
第6次 ：2021-07-13 11:39 — 4天
第7次 ：2021-07-16 11:39 — 7天
第8次 ：2021-07-24 11:39 — 15天

* 构建DOM树：将HTML用HTML解析器解析输出树状结构的DOM
* 样式计算：1.将CSS文本转换为浏览器可以理解的结构——styleSheets；2.转换样式表中的属性值，使其标准化；3.计算出DOM树中每个节点的具体样式
* 布局阶段：计算出DOM树中可见元素的几何位置，这个计算过程叫布局；
    1.创建布局树：
        遍历DOM树中所有可见节点，并把这些节点加到布局中；
        而不可见的节点会被布局树忽略掉
    2.布局计算
* 分层：渲染引擎还需要为特定的节点生成专用的图层，并生成一颗对应的图层树；浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。
* 图层绘制：渲染引擎会把图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表
* 栅格化操作：绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程完成的。合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是将图块转换为位图。

1. 渲染进程将HTML内容转换为能够读懂的DOM树结构。
2. 渲染引擎将CSS样式表转换为浏览器可以理解的styleSheets，计算出DOM节点的样式
3. 创建布局树，并计算元素的布局信息
4. 对布局树进行分层，并生成分层树
5. 为每个图层生成绘制列表，并将其提交到合成线程
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图
7. 合成线程发送绘制图块命令DrawQuad给浏览器进程
8. 浏览器进程根据DrawQuad消息生成页面，并显示到显示器上。

### 进程与线程的区别
第1次 ：2021-07-09 11:46 — 5分钟  1
第2次 ：2021-07-09 12:11 — 30分钟  1
第3次 ：2021-07-09 23:41 — 12小时  1
第4次 ：2021-07-10 11:41 — 1天  1
第5次 ：2021-07-11 11:41 — 2天  1
第6次 ：2021-07-13 11:41 — 4天
第7次 ：2021-07-16 11:41 — 7天
第8次 ：2021-07-24 11:41 — 15天
进程是系统进行资源分配和调度的一个独立单位
线程是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位
一个进程至少有一个线程组成
线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源，但是它可与同属一个进程的其他的线程共享进程所有的全部资源

### 进程间通信方式
第1次 ：2021-07-09 11:48 — 5分钟  1
第2次 ：2021-07-09 12:13 — 30分钟  1
第3次 ：2021-07-09 23:43 — 12小时  1
第4次 ：2021-07-10 11:43 — 1天  1
第5次 ：2021-07-11 11:43 — 2天   1
第6次 ：2021-07-13 11:43 — 4天
第7次 ：2021-07-16 11:43 — 7天
第8次 ：2021-07-24 11:43 — 15天
  管道通信
  消息队列通信
  信号量通信
  共享内存通信
  套接字通信

### 垃圾回收
第1次 ：2021-07-09 11:58 — 5分钟   1
第2次 ：2021-07-09 12:23 — 30分钟  1
第3次 ：2021-07-09 23:53 — 12小时  1
第4次 ：2021-07-10 11:53 — 1天  1
第5次 ：2021-07-11 11:53 — 2天  1
第6次 ：2021-07-13 11:53 — 4天
第7次 ：2021-07-16 11:53 — 7天
第8次 ：2021-07-24 11:53 — 15天

js具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存
引用计数：跟踪记录每个值被引用的次数，如果次数为0则回收
标记清除：就是当变量进入执行环境的时候标记为”进入环境“，离开执行环境的时候标记为”离开环境“

在V8中会把堆分为新生代和老生代俩个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象

新生代中用Scavenge算法来处理。就是把新生代空间对半划分为俩个区域，一半是对象区域，一半是空闲区域

新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

垃圾清理阶段，会把存活的对象复制到空闲区域中，同时把这些对象有序地排列起来，所以这个复制过程，也就相当于完成来内存整理操作。

完成复制后，对象区域与空闲区域进行角色翻转，这样就完成来垃圾对象的回收操作。经过俩次垃圾回收依然还存活的对象，会被移动到老生区。这就是对象晋升策略

老生代采用采用标记-清除的算法进行垃圾回收的