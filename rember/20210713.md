### MVVM的理解
第1次 ：2021-07-13 17:29 — 5分钟  1
第2次 ：2021-07-13 17:54 — 30分钟  1
第3次 ：2021-07-14 05:24 — 12小时
第4次 ：2021-07-14 17:24 — 1天   1
第5次 ：2021-07-15 17:24 — 2天 
第6次 ：2021-07-17 17:24 — 4天
第7次 ：2021-07-20 17:24 — 7天
第8次 ：2021-07-28 17:24 — 15天
 model view viewmodel
 dom listen
 data bind
 模型指的是后端传递的数据 视图指的是页面 视图模型和mvvm的核心 主要有俩个方向
    第一个方向是把模型转换为视图 实现方式是数据绑定
    第二个方向是把视图转换为模型 实现方式是DOM事件监听
    这俩个方向都实现的 我们称之为数据的双向绑定
    总结：模型和视图是通过视图模型建立通信，通常viewmodel 要实现一个observe观察者，
    当数据发生变化时，viewmodel能够监听到这种变化，然后通知数据做改动，这实际上就实现了数据的双向绑定
    viewmodel可以互相通信。

### v-show 和 v-if 的区别
第1次 ：2021-07-13 17:08 — 5分钟  1
第2次 ：2021-07-13 17:33 — 30分钟  1
第3次 ：2021-07-14 05:03 — 12小时  1
第4次 ：2021-07-14 17:03 — 1天
第5次 ：2021-07-15 17:03 — 2天
第6次 ：2021-07-17 17:03 — 4天
第7次 ：2021-07-20 17:03 — 7天
第8次 ：2021-07-28 17:03 — 15天
实现本质方法区别
vue-show本质就是标签display设置为none，控制隐藏
vue-if是动态的向DOM树内添加或者删除DOM元素

编译的区别
v-show其实就是在控制css
v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件

编译的条件
v-show都会编译，初始值为false，只是将display设为none，但它也编译了
v-if初始值为false，就不会编译了

性能
v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故v-show性能更好一点。

### 说一下虚拟DOM以及KEY属性的作用？
第1次 ：2021-07-13 17:42 — 5分钟 
第2次 ：2021-07-13 18:07 — 30分钟  1
第3次 ：2021-07-14 05:37 — 12小时  1
第4次 ：2021-07-14 17:37 — 1天  1
第5次 ：2021-07-15 17:37 — 2天
第6次 ：2021-07-17 17:37 — 4天
第7次 ：2021-07-20 17:37 — 7天
第8次 ：2021-07-28 17:37 — 15天
由于在浏览器中操作DOM是很昂贵的。频繁的操作DOM，会产生一定的性能问题。这就是虚拟DOM的产生原因。

virtual dom本质就是用一个原生的JS对象去描述一个DOM节点。是对真实DOM的一层抽象。（也就是源码中的VNode类）

虚拟DOM的实现原理主要包括了一下3部分：
  用javascript对象模拟真实DOM树，对真实DOM进行抽象；
  diff算法 一 比较俩颗虚拟DOM树的差异
  patch算法 —— 将俩个虚拟DOM独享的差异应用到真实的DOM树

  Key是为vue中vnode的唯一标记，通过这个key，我们的diff操作可以：
  更准确：因为带key就不是就地复用了，在sameNode函数a.key === b.key对比中就可以避免就地复用的情况。所以会更加准确
  更快速：利用key的唯一性生成map对象来获取对应节点，比遍历方式更快

### 描述vue组件生命周期
第1次 ：2021-07-13 17:42 — 5分钟
第2次 ：2021-07-13 18:07 — 30分钟  1
第3次 ：2021-07-14 05:37 — 12小时
第4次 ：2021-07-14 17:37 — 1天  1
第5次 ：2021-07-15 17:37 — 2天
第6次 ：2021-07-17 17:37 — 4天
第7次 ：2021-07-20 17:37 — 7天
第8次 ：2021-07-28 17:37 — 15天
* beforeCreate 实例初始化之后，数据观察和事件配置完成之前被调用
* created 实例创建完成之后，数据观测和事件配置完成了，可以做一些初始数据的获取，无法与dom进行交互
* beforeMount 发生挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟DOM已经创建完成，即将开始渲染。可以进行数据的修改不会触发update.
* Mounted 真实的DOM挂载完毕，数据完成双向绑定，可以访问到DOM节点，使用$refs属性对DOM进行操作
* beforeUpdate 发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染
* updated 发生在更新完成之后，当前阶段组件DOM已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。
* activated  keep-alive缓存组件激活时
* deActiveted keep-alive缓存组件停用时
* beforeDestory 发生在实例销毁之前，在当前阶段实例完全可以被使用，可以在这时进行善后收尾工作。
* destoryed 实例销毁

组件调用的顺序都是先父后子，渲染完成是先子后父
组件销毁操作是先父后子，销毁完成是先子后父

### vue组件如何通讯
第1次 ：2021-07-13 17:43 — 5分钟
第2次 ：2021-07-13 18:08 — 30分钟   1
第3次 ：2021-07-14 05:38 — 12小时 
第4次 ：2021-07-14 17:38 — 1天  1
第5次 ：2021-07-15 17:38 — 2天
第6次 ：2021-07-17 17:38 — 4天
第7次 ：2021-07-20 17:38 — 7天
第8次 ：2021-07-28 17:38 — 15天
父子组件通信
  父对子  props 子对父 $on、$emit
  获取父子组件实例 $parent、$children 数组
    ref 获取实例的方法调用组件的属性或者方法
    provide、inject
  兄弟组件通信
    eventBus vuex
  跨级组件通信
    vuex $attrs $listeners provide inject

### 双向数据绑定 v-model的实现原理
第1次 ：2021-07-13 17:44 — 5分钟
第2次 ：2021-07-13 18:09 — 30分钟  1
第3次 ：2021-07-14 05:39 — 12小时
第4次 ：2021-07-14 17:39 — 1天  1
第5次 ：2021-07-15 17:39 — 2天
第6次 ：2021-07-17 17:39 — 4天
第7次 ：2021-07-20 17:39 — 7天
第8次 ：2021-07-28 17:39 — 15天
  v-model是用来在表单控件或组件上创建双向绑定的
  他的本质是v-bind和v-on的语法糖
  在一个组件上使用v-model，默认会为组件绑定名为value的prop和名为input的事件

### computed 有何特点
第1次 ：2021-07-13 17:46 — 5分钟
第2次 ：2021-07-13 18:11 — 30分钟  1
第3次 ：2021-07-14 05:41 — 12小时
第4次 ：2021-07-14 17:41 — 1天   1
第5次 ：2021-07-15 17:41 — 2天
第6次 ：2021-07-17 17:41 — 4天
第7次 ：2021-07-20 17:41 — 7天
第8次 ：2021-07-28 17:41 — 15天

computed：是计算属性，依赖其他属性值，并且computed的值有缓存。
只有它依赖的属性值发生改变，下一次获取computed的值时才会重新计算computed的值

watch没有缓存性，每当监听的数据变化时都会执行回调进行后续操作
数值计算并且依赖于其他数据时，应该使用computed，因为可以利用computed的缓存特性，避免每次获取值时，都要重新计算。
当我们需要在数据变化时执行异步或开销较大的操作时，应该使用watch。
使用watch选项允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。
这些都是计算属性无法做到的

### 为何组件data必须是一个函数？

### 你的接口请求一般放在哪个生命周期中？
第1次 ：2021-07-13 17:46 — 5分钟
第2次 ：2021-07-13 18:11 — 30分钟  1
第3次 ：2021-07-14 05:41 — 12小时
第4次 ：2021-07-14 17:41 — 1天   1
第5次 ：2021-07-15 17:41 — 2天
第6次 ：2021-07-17 17:41 — 4天
第7次 ：2021-07-20 17:41 — 7天
第8次 ：2021-07-28 17:41 — 15天

created 、beforeMount beforeMounted
放到created中 能更快获取数据 减少loading时间

### 如何将组件所有props传递给子组件？
第1次 ：2021-07-13 17:46 — 5分钟
第2次 ：2021-07-13 18:11 — 30分钟
第3次 ：2021-07-14 05:41 — 12小时
第4次 ：2021-07-14 17:41 — 1天   1
第5次 ：2021-07-15 17:41 — 2天
第6次 ：2021-07-17 17:41 — 4天
第7次 ：2021-07-20 17:41 — 7天
第8次 ：2021-07-28 17:41 — 15天
* $props
* <User v-bind="$props" />

### 多个组件有相同的逻辑，如何抽离？
* mixin

### 什么是mixin?
第1次 ：2021-07-13 17:46 — 5分钟
第2次 ：2021-07-13 18:11 — 30分钟
第3次 ：2021-07-14 05:41 — 12小时
第4次 ：2021-07-14 17:41 — 1天   1
第5次 ：2021-07-15 17:41 — 2天
第6次 ：2021-07-17 17:41 — 4天
第7次 ：2021-07-20 17:41 — 7天
第8次 ：2021-07-28 17:41 — 15天
mixin使我们能够为vue组件编写可插拔和可重用的功能。
如果你希望在多个组件之间重用一组组件选项，例如生命周期hook、方法等，则可以将其编写为mixin，并在组件中简单的引用它。
然后将mixin的内容合并到组件中。如果你要在mixin中定义生命周期hook，那么它在执行时将优化于组件自己的hook.

### 何时要使用异步组件？
组件很大的时候

### 何时需要使用keep-alive?
第1次 ：2021-07-13 17:46 — 5分钟
第2次 ：2021-07-13 18:11 — 30分钟
第3次 ：2021-07-14 05:41 — 12小时
第4次 ：2021-07-14 17:41 — 1天   1
第5次 ：2021-07-15 17:41 — 2天
第6次 ：2021-07-17 17:41 — 4天
第7次 ：2021-07-20 17:41 — 7天
第8次 ：2021-07-28 17:41 — 15天

* 缓存组件，不需要重复渲染
* 如多个静态tab页的切换
* 优化性能

### 何时需要使用beforeDestory
第1次 ：2021-07-13 17:46 — 5分钟
第2次 ：2021-07-13 18:11 — 30分钟
第3次 ：2021-07-14 05:41 — 12小时
第4次 ：2021-07-14 17:41 — 1天   1
第5次 ：2021-07-15 17:41 — 2天
第6次 ：2021-07-17 17:41 — 4天
第7次 ：2021-07-20 17:41 — 7天
第8次 ：2021-07-28 17:41 — 15天

* 解绑自定义事件event.$off
* 清除定时器
* 解绑自定义的DOM事件，如window scroll等

### 什么是作用域插槽