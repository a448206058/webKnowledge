### 宏任务
第1次 ：2021-07-12 10:04 — 5分钟  1
第2次 ：2021-07-12 10:29 — 30分钟   1
第3次 ：2021-07-12 21:59 — 12小时  1
第4次 ：2021-07-13 09:59 — 1天  1
第5次 ：2021-07-14 09:59 — 2天  1
第6次 ：2021-07-16 09:59 — 4天
第7次 ：2021-07-19 09:59 — 7天
第8次 ：2021-07-27 09:59 — 15天

页面中的大部分任务都是在主线程上执行的，这些任务包括了：
* 渲染事件（如解析DOM、计算布局、绘制）；
* 用户交互事件
* JavaScript脚本执行事件
* 网络请求完成、文件读写完成事件

为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个for循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。

整体代码script、setTimeout、setInterval、setImmediate

### 微任务
第1次 ：2021-07-12 10:06 — 5分钟   1
第2次 ：2021-07-12 10:31 — 30分钟  1
第3次 ：2021-07-12 22:01 — 12小时   1
第4次 ：2021-07-13 10:01 — 1天  1
第5次 ：2021-07-14 10:01 — 2天  1
第6次 ：2021-07-16 10:01 — 4天
第7次 ：2021-07-19 10:01 — 7天
第8次 ：2021-07-27 10:01 — 15天

异步回调的概念，其主要有俩种方式。
第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。

第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。

微任务就是一个需要异步执行的函数，执行事件是在主函数执行结束之后、当前宏任务结束之前。

产生微任务有俩种方式：

第一种方式是使用MutationObserver监控某个DOM节点，然后再通过JavaScript来修改这个节点，或者为这个节点添加、删除部分子节点，当DOM节点发生变化时，就会产生DOM变化记录的微任务。

第二种方式是使用Promise，当调用Promise.resolve()或者Promise.reject()的时候，也会产生微任务。

通过DOM节点变化产生的微任务或者使用Promise产生的微任务都会被JavaScript引擎按照顺序来保存到微任务队列中

通常情况下，在当前宏任务中的JavaScript快执行完成时，也就在JavaScript引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。

如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8引擎一直循环执行微任务队列中的任务，知道队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。

原生promise中then方法、process.nextTick、MutationObserver

微任务先于宏任务执行 如果宏任务中有微任务 会先执行完微任务再执行宏任务

### DOM Tree是如何构建的？
第1次 ：2021-07-12 10:08 — 5分钟   1
第2次 ：2021-07-12 10:33 — 30分钟  1
第3次 ：2021-07-12 22:03 — 12小时  1
第4次 ：2021-07-13 10:03 — 1天  1
第5次 ：2021-07-14 10:03 — 2天  1
第6次 ：2021-07-16 10:03 — 4天
第7次 ：2021-07-19 10:03 — 7天
第8次 ：2021-07-27 10:03 — 15天
转码：浏览器将接收到的二进制数据按照指定编码格式转化成HTML字符串
生成Tokens:之后开始parser，浏览器会将HTML字符串解析成Tokens
构建Nodes:对Node添加特定的属性，通过指针确定Node的父、子、兄弟关系和所属treeScope
生成DOM Tree:通过node包含的指针确定的关系构建出dom

### 什么是同源策略？
第1次 ：2021-07-12 10:10 — 5分钟  1
第2次 ：2021-07-12 10:35 — 30分钟  1
第3次 ：2021-07-12 22:05 — 12小时  1
第4次 ：2021-07-13 10:05 — 1天  1
第5次 ：2021-07-14 10:05 — 2天  1
第6次 ：2021-07-16 10:05 — 4天
第7次 ：2021-07-19 10:05 — 7天
第8次 ：2021-07-27 10:05 — 15天

域名、协议、端口号相同

### 浏览器缓存
第1次 ：2021-07-12 10:15 — 5分钟    1
第2次 ：2021-07-12 10:40 — 30分钟  1
第3次 ：2021-07-12 22:10 — 12小时  1
第4次 ：2021-07-13 10:10 — 1天  1
第5次 ：2021-07-14 10:10 — 2天  1
第6次 ：2021-07-16 10:10 — 4天
第7次 ：2021-07-19 10:10 — 7天
第8次 ：2021-07-27 10:10 — 15天
memory cache  指内存中的缓存 是响应速度最快的一种缓存 缺点是缓存时间短，关闭页面就不存在了
service worker cache 是一种独立于主线程之外的javascript线程。可以用来实现离线缓存、消息推送以及网络代理等功能
disk cache 硬盘缓存
push cache 推送缓存 是http2中的内容，仅存在于会话阶段

### osi7层
第1次 ：2021-07-12 10:17 — 5分钟  1
第2次 ：2021-07-12 10:42 — 30分钟  1
第3次 ：2021-07-12 22:12 — 12小时  1
第4次 ：2021-07-13 10:12 — 1天  1
第5次 ：2021-07-14 10:12 — 2天  1
第6次 ：2021-07-16 10:12 — 4天
第7次 ：2021-07-19 10:12 — 7天
第8次 ：2021-07-27 10:12 — 15天
物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

### 常见的浏览器内核有哪些？
第1次 ：2021-07-12 10:21 — 5分钟   1
第2次 ：2021-07-12 10:46 — 30分钟  1
第3次 ：2021-07-12 22:16 — 12小时  1
第4次 ：2021-07-13 10:16 — 1天  1
第5次 ：2021-07-14 10:16 — 2天  1
第6次 ：2021-07-16 10:16 — 4天
第7次 ：2021-07-19 10:16 — 7天
第8次 ：2021-07-27 10:16 — 15天
chrome blink webkit
firefox gecko
safari webkit
edge edgeHTML
IE trident
phantomJS webkit

### 缓存策略
第1次 ：2021-07-12 10:26 — 5分钟
第2次 ：2021-07-12 10:51 — 30分钟  1
第3次 ：2021-07-12 22:21 — 12小时  1
第4次 ：2021-07-13 10:21 — 1天  1
第5次 ：2021-07-14 10:21 — 2天  1
第6次 ：2021-07-16 10:21 — 4天
第7次 ：2021-07-19 10:21 — 7天
第8次 ：2021-07-27 10:21 — 15天
强缓存
  强缓存是利用http头中的expires和cache-control俩个字段来控制的
  expires是一个时间戳、cache-control是一个时间长度
协商缓存
  协商缓存依赖于服务端与浏览器之间的通信
  last-modified和etag
  last-modified是一个时间戳
  etag是由服务器为每个资源生成的唯一标识字符串

### 如何实现跨域？
第1次 ：2021-07-12 10:27 — 5分钟
第2次 ：2021-07-12 10:52 — 30分钟  1
第3次 ：2021-07-12 22:22 — 12小时  1
第4次 ：2021-07-13 10:22 — 1天  1
第5次 ：2021-07-14 10:22 — 2天  1
第6次 ：2021-07-16 10:22 — 4天
第7次 ：2021-07-19 10:22 — 7天
第8次 ：2021-07-27 10:22 — 15天

  jsonp
  cors
  nginx 反向代理
    所有的客户端的请求都必须经过nginx的处理，nginx作为代理服务器再将请求转发
  window.name
  document.domain 二级域名相同的情况下
  postMessage+iframe

### cookie与session
第1次 ：2021-07-12 13:50 — 5分钟   1
第2次 ：2021-07-12 14:15 — 30分钟  1
第3次 ：2021-07-13 01:45 — 12小时  1
第4次 ：2021-07-13 13:45 — 1天  1
第5次 ：2021-07-14 13:45 — 2天  1
第6次 ：2021-07-16 13:45 — 4天
第7次 ：2021-07-19 13:45 — 7天
第8次 ：2021-07-27 13:45 — 15天
  cookie保存在客户端；session保存在服务端；
  session是由应用服务器维持的一个服务端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID，用该SessionID为标识符来存取服务端的Session存储空间

### tcp/udp协议
第1次 ：2021-07-12 14:56 — 5分钟   1
第2次 ：2021-07-12 15:21 — 30分钟  1
第3次 ：2021-07-13 02:51 — 12小时  1
第4次 ：2021-07-13 14:51 — 1天  1
第5次 ：2021-07-14 14:51 — 2天  1
第6次 ：2021-07-16 14:51 — 4天
第7次 ：2021-07-19 14:51 — 7天
第8次 ：2021-07-27 14:51 — 15天
 tcp 是面向连接的、可靠的、基于字节流的传输层通信协议 位于传输层
    特点是：
      面向连接
      仅支持单播功能
      可靠传输
      基于字节流
      提供双全功通信
    upd
      udp 是面向数据报、无连接、不可靠额传输层通信协议 和tcp一样用于处理数据包，是一种无连接的协议
      面向无连接
      支持单播 多播 广播功能
      不可靠传输
      面向报文

### http协议
第1次 ：2021-07-12 15:02 — 5分钟   1
第2次 ：2021-07-12 15:27 — 30分钟  1
第3次 ：2021-07-13 02:57 — 12小时  1
第4次 ：2021-07-13 14:57 — 1天
第5次 ：2021-07-14 14:57 — 2天  1
第6次 ：2021-07-16 14:57 — 4天
第7次 ：2021-07-19 14:57 — 7天
第8次 ：2021-07-27 14:57 — 15天

http协议是超文本传输协议，是用于万维网服务器传输文本到本地浏览器的传送协议。http是基于tcp/ip协议来传递数据，它不涉及数据包的传输
        简单快速 get、post、head、put、delete
        灵活 允许传输任意类型的数据对象
        无连接 限制每次连接只处理一个请求
        无状态 协议不保存之前的一切信息

### https
第1次 ：2021-07-12 15:10 — 5分钟  1
第2次 ：2021-07-12 15:35 — 30分钟  1
第3次 ：2021-07-13 03:05 — 12小时  1
第4次 ：2021-07-13 15:05 — 1天  1
第5次 ：2021-07-14 15:05 — 2天  1
第6次 ：2021-07-16 15:05 — 4天
第7次 ：2021-07-19 15:05 — 7天
第8次 ：2021-07-27 15:05 — 15天

https是在http上建立ssl加密层，并对传输数据进行加密，是http协议的安全版
主要作用是：
  1.对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全
  2.对网站服务器进行真实身份认证。

### https特点
第1次 ：2021-07-12 15:14 — 5分钟   1
第2次 ：2021-07-12 15:39 — 30分钟  1
第3次 ：2021-07-13 03:09 — 12小时  1
第4次 ：2021-07-13 15:09 — 1天  1
第5次 ：2021-07-14 15:09 — 2天  1
第6次 ：2021-07-16 15:09 — 4天
第7次 ：2021-07-19 15:09 — 7天
第8次 ：2021-07-27 15:09 — 15天

https协议的主要功能都基本依赖于TLS/SSL协议，TLS/SSL的功能实现利用非对称加密实现身份认证和密钥协商
1.解决内容可能被窃听的问题-加密
2.解决报文可能遭篡改的问题-数字签名
3.解决通信方身份可能被伪造的问题-数字证书

### http与https的区别
第1次 ：2021-07-12 15:48 — 5分钟  1
第2次 ：2021-07-12 16:13 — 30分钟  1
第3次 ：2021-07-13 03:43 — 12小时  1
第4次 ：2021-07-13 15:43 — 1天  1
第5次 ：2021-07-14 15:43 — 2天  1
第6次 ：2021-07-16 15:43 — 4天
第7次 ：2021-07-19 15:43 — 7天
第8次 ：2021-07-27 15:43 — 15天
http是明文传输协议，https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全
        https比http更加安全，利于seo
        https需要用到ssl证书
        https标准端口443，http标准端口80
        https基于应用层，http基于传输层
        https在浏览器显示绿色安全锁，http没有显示

#### http2及http3特性
第1次 ：2021-07-12 16:07 — 5分钟  1
第2次 ：2021-07-12 16:32 — 30分钟
第3次 ：2021-07-13 04:02 — 12小时  1
第4次 ：2021-07-13 16:02 — 1天   1
第5次 ：2021-07-14 16:02 — 2天   1
第6次 ：2021-07-16 16:02 — 4天
第7次 ：2021-07-19 16:02 — 7天
第8次 ：2021-07-27 16:02 — 15天
Http1.1的缺陷
            由于队头阻塞导致带宽无法被充分利用
            无状态特性-带来的巨大的http头部
            明文传输-带来的不安全性
            不支持服务器推送消息

        http2
            基于SPDY，专注于性能，最大的目标是在用户和网站间只用一个连接
            二进制传输
                http2传输数据量的大幅减少，主要是以二进制方式传输和header压缩
            header压缩
            多路复用
            serve push
            提高安全性
       http3
            基于udp协议 让http跑在quic上
            实现了类似tcp的流量控制、传输可靠性的功能
            实现了快速握手功能
            继承了TLS加密功能
            多路复用，彻底解决TCP中队头阻塞问题
       http1.1有俩个主要缺点：安全不足和性能不高
       http2完全兼容http1，是更安全的http、更快的https，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而
       大幅度提高上网体验
       QUIC基于UDP实现，是http3中的底层支撑协议，该协议基于UDP，又取了tcp的计划，实现了即快又可靠的协议

### Chrome进程架构
第1次 ：2021-07-12 15:50 — 5分钟   1
第2次 ：2021-07-12 16:15 — 30分钟  1
第3次 ：2021-07-13 03:45 — 12小时  1
第4次 ：2021-07-13 15:45 — 1天  1
第5次 ：2021-07-14 15:45 — 2天  1
第6次 ：2021-07-16 15:45 — 4天
第7次 ：2021-07-19 15:45 — 7天
第8次 ：2021-07-27 15:45 — 15天
1个浏览器主进程（Browser Process）
多个渲染进程（Render Process）
1个GPU进程（GPU Process）
1个网络进程（NewWork Process）
多个插件进程（Plugin Process）

### HTTP 报文结构是怎样的？
起始行 + 头部 + 空行 + 实体

### GET 和 POST 有什么区别？
从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
从幂等性的角度，GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的)
从TCP的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

### 如何理解 URI？
URI, 全称为(Uniform Resource Identifier), 也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。

scheme 表示协议名，比如http, https, file等等。后面必须和://连在一起。
user:passwd@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。
host:port表示主机名和端口。
path表示请求路径，标记资源所在位置。
query表示查询参数，为key=val这种形式，多个键值对之间用&隔开。
fragment表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。

URI 只能使用ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。

因此，URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%。

### 如何理解 HTTP 状态码？
RFC 规定 HTTP 的状态码为三位数，被分为五类:

1xx: 表示目前是协议处理的中间状态，还需要后续操作。
2xx: 表示成功状态。
3xx: 重定向状态，资源位置发生变动，需要重新请求。
4xx: 请求报文有误。
5xx: 服务器端发生错误。

1xx
101 Switching Protocols。在HTTP升级为WebSocket的时候，如果服务器同意变更，就会发送状态码 101。
2xx
200 OK是见得最多的成功状态码。通常在响应体中放有数据。
204 No Content含义与 200 相同，但响应头后没有 body 数据。
206 Partial Content顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段Content-Range。
3xx
301 Moved Permanently即永久重定向，对应着302 Found，即临时重定向。
比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。
而如果只是暂时不可用，那么直接返回302即可，和301不同的是，浏览器并不会做缓存优化。
304 Not Modified: 当协商缓存命中时会返回这个状态码。详见浏览器缓存
4xx
400 Bad Request: 开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。
403 Forbidden: 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。
404 Not Found: 资源未找到，表示没在服务器上找到相应的资源。
405 Method Not Allowed: 请求方法不被服务器端允许。
406 Not Acceptable: 资源无法满足客户端的条件。
408 Request Timeout: 服务器等待了太长时间。
409 Conflict: 多个请求发生了冲突。
413 Request Entity Too Large: 请求体的数据过大。
414 Request-URI Too Long: 请求行里的 URI 太大。
429 Too Many Request: 客户端发送的请求过多。
431 Request Header Fields Too Large请求头的字段内容太大。
5xx
500 Internal Server Error: 仅仅告诉你服务器出错了，出了啥错咱也不知道。
501 Not Implemented: 表示客户端请求的功能还不支持。
502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。
503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务。
