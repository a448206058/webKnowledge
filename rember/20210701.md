## JS

### 内置类型
第1次 ：2021-07-01 09:33 — 5分钟     1   
第2次 ：2021-07-01 09:58 — 30分钟    1
第3次 ：2021-07-01 21:28 — 12小时
第4次 ：2021-07-02 09:28 — 1天
第5次 ：2021-07-03 09:28 — 2天
第6次 ：2021-07-05 09:28 — 4天
第7次 ：2021-07-08 09:28 — 7天
第8次 ：2021-07-16 09:28 — 15天

有7种：null、string、object、number、undefined、boolean、ES6的symbol
基本类型：null、string、number、undefined、boolean、symbol
引用类型：object

NaN也是number类型、NaN不等于自身

### Typeof
第1次 ：2021-07-01 09:42 — 5分钟    1
第2次 ：2021-07-01 10:07 — 30分钟  1
第3次 ：2021-07-01 21:37 — 12小时
第4次 ：2021-07-02 09:37 — 1天
第5次 ：2021-07-03 09:37 — 2天
第6次 ：2021-07-05 09:37 — 4天
第7次 ：2021-07-08 09:37 — 7天
第8次 ：2021-07-16 09:37 — 15天

对于基本类型，除了null都可以显示正确的类型
typeof null 为object

typeof对象 显示 object
typeof console.log 为 function

可以通过Object.prototype.toString.call(xx)来获取变量的类型

### 类型转换

### 转Boolean
第1次 ：2021-07-01 09:46 — 5分钟  1
第2次 ：2021-07-01 10:11 — 30分钟 1
第3次 ：2021-07-01 21:41 — 12小时
第4次 ：2021-07-02 09:41 — 1天
第5次 ：2021-07-03 09:41 — 2天
第6次 ：2021-07-05 09:41 — 4天
第7次 ：2021-07-08 09:41 — 7天
第8次 ：2021-07-16 09:41 — 15天

在条件判断时，除了undefined,null,false,NaN,'',0,-0,其他所有值都转为true,包括对象

### 对象转基本类型
第1次 ：2021-07-01 09:54 — 5分钟  1
第2次 ：2021-07-01 10:19 — 30分钟 1
第3次 ：2021-07-01 21:49 — 12小时
第4次 ：2021-07-02 09:49 — 1天
第5次 ：2021-07-03 09:49 — 2天
第6次 ：2021-07-05 09:49 — 4天
第7次 ：2021-07-08 09:49 — 7天
第8次 ：2021-07-16 09:49 — 15天

对象在转换基本类型时，首先会调用valueOf然后调用toString。并且这俩个方法是可以重写的。
也可以重写Symbol.toPrimitive，该方法在转基本类型时调用优先级最高
```JavaScript
let a  = {
  valueOf() {
    return 0;
  }
  toString() {
    return '1';
  }
  [Symbol.toPrimitive]() {
    return 2;
  }
}

1 + 1 // 3
```

### 四则运算符
第1次 ：2021-07-01 10:06 — 5分钟   1
第2次 ：2021-07-01 10:31 — 30分钟   1
第3次 ：2021-07-01 22:01 — 12小时
第4次 ：2021-07-02 10:01 — 1天
第5次 ：2021-07-03 10:01 — 2天
第6次 ：2021-07-05 10:01 — 4天
第7次 ：2021-07-08 10:01 — 7天
第8次 ：2021-07-16 10:01 — 15天

只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。
```JavaScript
1 + '1' // '11'
2 * '2' // 4
[1, 2] + [2, 1] // '1, 22, 1'
// [1, 2].toString() -> '1, 2'
// [2, 1].toString() -> '2, 1'


'a' + + 'b' // "aNaN"
// + 'b' NaN

```

### == 操作符
第1次 ：2021-07-01 10:19 — 5分钟   1
第2次 ：2021-07-01 10:44 — 30分钟  1
第3次 ：2021-07-01 22:14 — 12小时
第4次 ：2021-07-02 10:14 — 1天
第5次 ：2021-07-03 10:14 — 2天
第6次 ：2021-07-05 10:14 — 4天
第7次 ：2021-07-08 10:14 — 7天
第8次 ：2021-07-16 10:14 — 15天

toPrimitive 对象转基本类型
[] == ![]

### 比较运算符
第1次 ：2021-07-01 10:21 — 5分钟   1
第2次 ：2021-07-01 10:46 — 30分钟   1
第3次 ：2021-07-01 22:16 — 12小时
第4次 ：2021-07-02 10:16 — 1天
第5次 ：2021-07-03 10:16 — 2天
第6次 ：2021-07-05 10:16 — 4天
第7次 ：2021-07-08 10:16 — 7天
第8次 ：2021-07-16 10:16 — 15天

1. 如果是对象，就通过toPrimitive转换对象
2. 如果是字符串，就通过unicode字符串索引来比较

### 原型
第1次 ：2021-07-01 10:56 — 5分钟    1
第2次 ：2021-07-01 11:21 — 30分钟
第3次 ：2021-07-01 22:51 — 12小时
第4次 ：2021-07-02 10:51 — 1天
第5次 ：2021-07-03 10:51 — 2天
第6次 ：2021-07-05 10:51 — 4天
第7次 ：2021-07-08 10:51 — 7天
第8次 ：2021-07-16 10:51 — 15天

每个函数都会创建一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性（指向原型对象）。所有原型对象自动获得一个名为constructor的属性，指回与之关联的构造函数。Person.prototype.constructor指向Person。__proto__属性可以访问对象的原型，指回与之关联的构造函数。Person.prototype.constructor指向Person。__proto__属性可以访问对象的原型
  ```JavaScript
    console.log(Person.prototype.constructor === Person); // true

    console.log(Person.prototype.__proto__ === Object.prototype); // true
    console.log(Person.prototype.__proto__.constructor === Object); // true
  ```