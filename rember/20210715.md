### vue3
第1次 ：2021-07-15 11:14 — 5分钟  1
第2次 ：2021-07-15 11:39 — 30分钟  1
第3次 ：2021-07-15 23:09 — 12小时  1
第4次 ：2021-07-16 11:09 — 1天  1
第5次 ：2021-07-17 11:09 — 2天
第6次 ：2021-07-19 11:09 — 4天  1
第7次 ：2021-07-22 11:09 — 7天  1
第8次 ：2021-07-30 11:09 — 15天  1
reflect作用
* 和proxy能力一一对应
* 规范化、标准化、函数式
* 替代掉Object上的工具函数

### vue3.x响应式数据原理
第1次 ：2021-07-15 11:16 — 5分钟  1
第2次 ：2021-07-15 11:41 — 30分钟 1
第3次 ：2021-07-15 23:11 — 12小时  1
第4次 ：2021-07-16 11:11 — 1天  1
第5次 ：2021-07-17 11:11 — 2天   
第6次 ：2021-07-19 11:11 — 4天  1
第7次 ：2021-07-22 11:11 — 7天  1
第8次 ：2021-07-30 11:11 — 15天  1
vue3.x改用proxy替代object.definePrototype
        因为proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。
        proxy只会代理对象的第一层，vue3是怎样处理这个问题
        判断当前Reflect.get的返回值是否为object，如果是则再通过reactive方法做代理，这样就实现了深度观测。
        监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？我们可以判断key是否被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上俩个条件时，
        才有可能执行trigger。

### proxy与object.defineProperty优劣对比
第1次 ：2021-07-15 11:18 — 5分钟  1
第2次 ：2021-07-15 11:43 — 30分钟  1
第3次 ：2021-07-15 23:13 — 12小时 1
第4次 ：2021-07-16 11:13 — 1天  1
第5次 ：2021-07-17 11:13 — 2天
第6次 ：2021-07-19 11:13 — 4天  1
第7次 ：2021-07-22 11:13 — 7天  1
第8次 ：2021-07-30 11:13 — 15天  1
Proxy的优势如下：
            proxy可以直接监听对象而非属性;
            proxy可以直接监听数组的变化
            proxy有多达13种拦截方法，不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的;
            proxy返回的是一个新对象，我们可以只操作新的对象达到目的，而object.defineProperty只能遍历对象属性直接修改；
            proxy作为新标准将受到浏览器厂商重点持续的性能优化。
        object.defineProperty有事如下：
            兼容性好，支持IE9，而proxy的存在浏览器兼容性问题，而且无法用Polyfill磨平


### vue3.x生命周期变化
第1次 ：2021-07-15 11:34 — 5分钟  1
第2次 ：2021-07-15 11:59 — 30分钟  1
第3次 ：2021-07-15 23:29 — 12小时  1
第4次 ：2021-07-16 11:29 — 1天  1
第5次 ：2021-07-17 11:29 — 2天
第6次 ：2021-07-19 11:29 — 4天  1
第7次 ：2021-07-22 11:29 — 7天  1
第8次 ：2021-07-30 11:29 — 15天  1

被替换
          1.beforeCreate -> setup()
          2.created -> setup()
      重命名
          1.beforeMount -> onBeforeMount
          2.mounted -> onMounted
          3.beforeUpdate -> onBeforeUpdate
          4.updated -> onUpdated
          5.beforeDestroy -> onBeforeUnmount
          6.destroyed -> onUnmounted
          7.errorCaptured -> onErrorCaptured
      新增的
          debug回调钩子
          1.onRenderRracked
          2.onRenderTriggered

### composition api 核心语法
第1次 ：2021-07-15 11:37 — 5分钟  1 
第2次 ：2021-07-15 12:02 — 30分钟  1
第3次 ：2021-07-15 23:32 — 12小时  1
第4次 ：2021-07-16 11:32 — 1天  1
第5次 ：2021-07-17 11:32 — 2天
第6次 ：2021-07-19 11:32 — 4天  1
第7次 ：2021-07-22 11:32 — 7天  1
第8次 ：2021-07-30 11:32 — 15天  1
setup 主执行函数
       setup是compisitionAPI的核心，可以说也是整个vue3.x的核心
           setup将vue2.x的beforeCreate和created代替了，以一个setup函数的形式，可以灵活组织代码了
           setup还可以return数据或者template，相当于把data和render也一并代替了
           setup取消了this setup(props, context)
       reactive方法
           被reactive方法包裹后的对象就变成了一个代理对象，相当于vue2.x中的vue.observable()。也就可以实现页面和
           数据之间的双向绑定了。
           这个包裹的方法是deep的，对所有嵌套的属性都生效。
           const obj2 = reactive({
               cnt: 1
           })
       ref方法
           被ref方法包裹后的元素就变成了一个代理对象。元素指基本元素
           ref一般适用于某个元素，而reactive适用于一个对象
           setup(){
               const count = ref(100)

               const count = reactive({
                   value: 100
               })

               console.log(count.value)
           }
           在template上使用时，会自动打开unwrap，不需要再加.value
       isRef方法
           判断一个对象是否ref代理对象。
           const unwrapped = isRef(foo ? foo.value : foo)
       toRefs方法
           将一个reactive代理对象打平，转换为ref代理对象，使得对象的属性可以直接在template上使用
       computed函数
           与vue2.x中的作用类似，获取一个计算结果。不仅支持取值get，还支持赋值set。
           注意：结果是一个ref代理对象，js中取值需要.value
           const plusone = computed({
               get: () => count.value + 100,
               set: val => { count.value = val - 1}
           })
       readonly函数
           使用readonly函数，可以把普通object对象、reactive对象、ref对象返回一个只读对象

### vue3.x新特性
第1次 ：2021-07-15 11:38 — 5分钟  1
第2次 ：2021-07-15 12:03 — 30分钟  1
第3次 ：2021-07-15 23:33 — 12小时  1
第4次 ：2021-07-16 11:33 — 1天  1
第5次 ：2021-07-17 11:33 — 2天
第6次 ：2021-07-19 11:33 — 4天  1
第7次 ：2021-07-22 11:33 — 7天  1
第8次 ：2021-07-30 11:33 — 15天  1
1.compostion api 合成api
       2.取消vue全局变量
           取消了全局变量vue，改为实例函数createApp()创建实例对象。
       3.自定义指令directives api调整
       4 component组件支持v-model指令
           子组件调用父组件的方法通过this.$emit()
           数据双向绑定 .sync修饰符
           vue3.x 直接v-model替代了.sync
       5 fragments template支持有多个根节点
       6 suspense template fallback 组件
           <suspense>
               <template #default>
               </template>
               <template #fallback>
               </template>
           </suspense>
       7 teleport template dom占位传递组件


### 说说你对SSR的了解 
第1次 ：2021-07-15 11:39 — 5分钟  1
第2次 ：2021-07-15 12:04 — 30分钟  1
第3次 ：2021-07-15 23:34 — 12小时  1
第4次 ：2021-07-16 11:34 — 1天  1
第5次 ：2021-07-17 11:34 — 2天 
第6次 ：2021-07-19 11:34 — 4天  1
第7次 ：2021-07-22 11:34 — 7天  1
第8次 ：2021-07-30 11:34 — 15天  1
 SSR也就是服务端渲染，也就是将VUE在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端
SSR的优势：更好的SEO；首屏加载速度更快
SSR的缺点：开发条件会受到限制，服务器端渲染只支持beforeCreate和created俩个钩子
当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node环境
 更多的服务端负载；

### 说说你对SPA单页面的理解，它的缺点是什么？ 
第1次 ：2021-07-15 14:33 — 5分钟  1
第2次 ：2021-07-15 14:58 — 30分钟  1
第3次 ：2021-07-16 02:28 — 12小时  1
第4次 ：2021-07-16 14:28 — 1天  1
第5次 ：2021-07-17 14:28 — 2天
第6次 ：2021-07-19 14:28 — 4天  1
第7次 ：2021-07-22 14:28 — 7天  1
第8次 ：2021-07-30 14:28 — 15天  1
 SPA仅在web页面初始化时加载相应的HTML、JavaScript和CSS
一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现HTML内容的变换，UI与用户的交互，
避免页面的重新加载。
优点：用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
 基于上面一点，SPA相对对服务器压力小；
 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理。
缺点：初次加载耗时多：为实现单页web应用及显示效果，需要在加载页面的时候javascript、css统一加载，部分页面按需加载；
  前进后退路由管理：由于单页面应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
  SEO难度较大：由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势。

### XSS攻击
第1次 ：2021-07-15 15:09 — 5分钟  1
第2次 ：2021-07-15 15:34 — 30分钟  1
第3次 ：2021-07-16 03:04 — 12小时  1
第4次 ：2021-07-16 15:04 — 1天  1
第5次 ：2021-07-17 15:04 — 2天
第6次 ：2021-07-19 15:04 — 4天  1
第7次 ：2021-07-22 15:04 — 7天  1
第8次 ：2021-07-30 15:04 — 15天  1
XSS（Cross-Site Scripting，跨站脚本攻击）是一种代码注入攻击。

根据攻击的来源，XSS攻击可以分为存储型（持久性）、反射性（非持久型）和DOM型三种

### 反射型XSS
第1次 ：2021-07-15 15:11 — 5分钟  1
第2次 ：2021-07-15 15:36 — 30分钟  1
第3次 ：2021-07-16 03:06 — 12小时  1
第4次 ：2021-07-16 15:06 — 1天  1
第5次 ：2021-07-17 15:06 — 2天
第6次 ：2021-07-19 15:06 — 4天  1
第7次 ：2021-07-22 15:06 — 7天  1
第8次 ：2021-07-30 15:06 — 15天  1
当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等，未进行过滤直接返回到用户的浏览器上。

攻击步骤：
1. 攻击者构造出特殊的URL，其中包含恶意代码
2. 用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

防御：
对字符串进行编码：对url的查询参数进行转义后再输出到页面。
```JavaScript
app.get('/welcome', function(req, res){
    // 对查询参数进行编码，避免反射型XSS攻击
    res.send(`${encodeURIComponent(req.query.type)}`);
})
```

### DOM型XSS
第1次 ：2021-07-15 15:17 — 5分钟  1
第2次 ：2021-07-15 15:42 — 30分钟  1
第3次 ：2021-07-16 03:12 — 12小时  1
第4次 ：2021-07-16 15:12 — 1天  1
第5次 ：2021-07-17 15:12 — 2天
第6次 ：2021-07-19 15:12 — 4天  1
第7次 ：2021-07-22 15:12 — 7天  1
第8次 ：2021-07-30 15:12 — 15天  1
DOM型XSS攻击，实际上就是前端JavaScript代码不够严谨，把不可信的内容插入到了页面。在使用.innerHTML、outerHTML、appendChild、document.write()等API时要特别小心，不要把不可信的数据作为HTML插到页面上，尽量使用.innerText、.textContent、.setAttribute()等。

攻击步骤：
1. 攻击者构造出特殊数据，其中包含恶意代码
2. 用户浏览器执行了恶意代码
3. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

防御：
防范DOM型XSS攻击的核心就是对输入内容进行转义（DOM中的内联事件监听器和链接跳转都能把字符串作为代码运行，需要对其内容进行检查）。
1. 对于url链接，直接使用encodeURIComponent转义
2. 非url
```JavaScript
function encodeHtml(str) {
    return str.replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
            .replace(/&/g, '&amp;')
            .replace(/\//g, '&#x2F;')
}
```
* 对于链接跳转，如<a href="xxx">或location.href="xxx"，要检验其内容，禁止javascript:开头的链接，和其他非法的scheme
* HTML转义是非常复杂的，在不同的情况下要采用不同的转义规则。如果采用了错误的转义规则，很有可能会埋下XSS隐患。
* 应当尽量避免自己写转义库，而应当采用成熟的、业界通用的转义库。

### 存储型XSS
第1次 ：2021-07-15 15:21 — 5分钟  1
第2次 ：2021-07-15 15:46 — 30分钟  1
第3次 ：2021-07-16 03:16 — 12小时  1
第4次 ：2021-07-16 15:16 — 1天  1
第5次 ：2021-07-17 15:16 — 2天
第6次 ：2021-07-19 15:16 — 4天  1
第7次 ：2021-07-22 15:16 — 7天  1
第8次 ：2021-07-30 15:16 — 15天  1
恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。存储型XSS攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出。

攻击步骤：
1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

防御：
1. 前端数据传递给服务器之前，先转义/过滤
2. 服务器接收到数据，在存储到数据库之前，进行转义/过滤
3. 前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤

4. Content Security Policy
在服务端使用HTTP的Content-Security-Policy头部来指定策略，或者在前端设置meta标签

```JavaScript
// 服务端
Content-Security-Policy: default-src 'self'

// 客户端
<meta http-equiv="Content-Security-Policy" content="form-action 'self';">
```
严格的CSP在XSS的防范中可以起到以下的作用：
禁止加载外域代码，防止复杂的攻击逻辑
禁止外域提交，网站被攻击后，用户的数据不会泄露到外域
禁止内联脚本执行
禁止未授权的脚本执行
合理使用上报可以及时发现XSS，利于尽快修复问题

5. 输入内容长度控制
6. 输入内容限制（可以限定不能包含特殊字符或者仅能输入数字等）
7. HTTP-only Cookie:禁止JavaScript读取敏感Cookie
8. 验证码：防止脚本冒充用户提交危险操作

### CSRF
第1次 ：2021-07-15 15:38 — 5分钟  1
第2次 ：2021-07-15 16:03 — 30分钟  1
第3次 ：2021-07-16 03:33 — 12小时  1
第4次 ：2021-07-16 15:33 — 1天  1
第5次 ：2021-07-17 15:33 — 2天
第6次 ：2021-07-19 15:33 — 4天  1
第7次 ：2021-07-22 15:33 — 7天  1
第8次 ：2021-07-30 15:33 — 15天  1

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击网站执行某项操作的目的。

常见的攻击类型：
* GET类型的CSRF
* POST类型的CSRF
* 链接类型的CSRF

防御：
1. 添加验证码
2. 判断请求的来源：检测Referer(并不安全，Referer可以被更改)
3. 使用Token
4. Samesute Cookie属性
Goole起草了一份草案来改进HTTP协议，为Set-Cookie响应头新增Samesite属性，它用来标明这个Cookie是个同站Cookie，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite有俩个属性值，分别是Strict和Lax,部署简单，并能有效防御CSRF攻击，但是存在兼容性问题。

### 点击劫持
第1次 ：2021-07-15 15:44 — 5分钟
第2次 ：2021-07-15 16:09 — 30分钟  1
第3次 ：2021-07-16 03:39 — 12小时  1
第4次 ：2021-07-16 15:39 — 1天  1
第5次 ：2021-07-17 15:39 — 2天
第6次 ：2021-07-19 15:39 — 4天  1
第7次 ：2021-07-22 15:39 — 7天  1
第8次 ：2021-07-30 15:39 — 15天  1
点击劫持是指在一个Web页面中隐藏了一个透明的iframe,用外层假页面诱导用户点击，实际上是在隐藏的frame上触发了点击事件进行一些用户不知情的操作

攻击流程：
1. 攻击者构建了一个非常有吸引力的网页
2. 将被攻击的页面放置在当前页面的iframe中
3. 使用样式将iframe叠加到非常有吸引力内容的上方
4. 将iframe设置为100%透明
5. 你被诱导点击了网页内容，你以为你点击的是**,实际上，你成功被攻击了

防御：
1. frame busting
```JavaScript
if (top.location != window.location) {
    top.location = window.location
}
```
HTML5中国的iframe的sandbox属性、IE中iframe的security属性等，都可以限制iframe页面中的JavaScript脚本执行，从而可以使得frame busting失效。
2. X-Frame-Options
X-Frame-Options是微软提出的一个HTTP头，专门用来防御利用iframe嵌套的点击劫持攻击
DENY:拒绝任何域加载
SAMEORIGIN:允许同源域下加载
ALLOW-FROM:可以定义允许frame加载的页面地址

### 防御工具
1. Arachni
2. Mozilla HTTP Observatory
3. w3af