### webpack的作用
第1次 ：2021-07-19 11:02 — 5分钟  1
第2次 ：2021-07-19 11:27 — 30分钟  1
第3次 ：2021-07-19 22:57 — 12小时   1
第4次 ：2021-07-20 10:57 — 1天  1
第5次 ：2021-07-21 10:57 — 2天
第6次 ：2021-07-23 10:57 — 4天
第7次 ：2021-07-26 10:57 — 7天
第8次 ：2021-08-03 10:57 — 15天

1.代码转换
2.文件优化
3.代码分割
4.模块合并
5.自动刷新
6.代码校验
7.自动发布

### 打包原理
第1次 ：2021-07-19 11:04 — 5分钟  1
第2次 ：2021-07-19 11:29 — 30分钟  1
第3次 ：2021-07-19 22:59 — 12小时  1
第4次 ：2021-07-20 10:59 — 1天  1
第5次 ：2021-07-21 10:59 — 2天
第6次 ：2021-07-23 10:59 — 4天
第7次 ：2021-07-26 10:59 — 7天
第8次 ：2021-08-03 10:59 — 15天
1. 初始化参数：从配置文件和shell语句中读取与合并参数，得到最终的参数；

2. 开始编译：用上一步得到的参数初始化compiler对象，加载所有配置的插件，通过执行对象的run方法开始执行编译；

3. 确定入口：根据配置中的entry找出所有入口文件

4. 编译模块：从入口文件出发，调用所有配置的loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过来本步骤的处理；
      
5. 完成模块编译：在经过第4步使用loader翻译完所有模块后，得到来每个模块被翻译后的最终内容及它们之间的依赖关系；
      
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，再将每个chunk转换成一个单独的文件加入输出列表中，这是可以修改输出内容的最后机会。

7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中；

### loader与plugin的区别
第1次 ：2021-07-19 11:07 — 5分钟  1
第2次 ：2021-07-19 11:32 — 30分钟  1
第3次 ：2021-07-19 23:02 — 12小时  1
第4次 ：2021-07-20 11:02 — 1天  1
第5次 ：2021-07-21 11:02 — 2天
第6次 ：2021-07-23 11:02 — 4天
第7次 ：2021-07-26 11:02 — 7天
第8次 ：2021-08-03 11:02 — 15天
loader，它是一个转换器，文件内容进行翻译，比如将es6转换为es5，单纯的文件转换过程
      plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不是直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，
      并且执行相对应的任务

### happypack的原理
第1次 ：2021-07-19 11:28 — 5分钟  1
第2次 ：2021-07-19 11:53 — 30分钟  1
第3次 ：2021-07-19 23:23 — 12小时  1
第4次 ：2021-07-20 11:23 — 1天  1
第5次 ：2021-07-21 11:23 — 2天
第6次 ：2021-07-23 11:23 — 4天
第7次 ：2021-07-26 11:23 — 7天
第8次 ：2021-08-03 11:23 — 15天

webpack中最耗时的就是loader的转换过程，转换的流程很长。happypack的原理就是把这部分的任务拆解成多个子进程去并行处理，减少构建事件
      通过new happypack()实例化，然后把任务交由实例统一调度分配。核心调度器会将一个个任务分配给空闲的子进程。处理完毕后发送给核心调度器。

### 如何优化webpack配置
第1次 ：2021-07-19 11:33 — 5分钟  1
第2次 ：2021-07-19 11:58 — 30分钟  1
第3次 ：2021-07-19 23:28 — 12小时  1
第4次 ：2021-07-20 11:28 — 1天  1
第5次 ：2021-07-21 11:28 — 2天
第6次 ：2021-07-23 11:28 — 4天
第7次 ：2021-07-26 11:28 — 7天
第8次 ：2021-08-03 11:28 — 15天

缩小文件查找范围
        优化load
        优化resolve.modules
        优化resolve.mafinFields
        优化resolve.alias
        优化resolve.extensions
        优化module.noPaese
      使用DLLPlugin
        基础模块抽离，打包到动态链接库
        需要使用模块，直接去动态链接库查找
      使用happypack 单线程变多线程
      使用paralleIUglifyPlugin
        开启多进程压缩代码，并行执行
      使用CDN加速
        静态资源放到cdn服务器上面
      tree shaking
        删除无用的代码
      提取公共代码
        防止相同资源重复加载
        减少网络流量及服务器成本
      使用prepack
        编译代码时提前计算结果放到编译后的结果中，而不是在代码运行才求值

### 那你说说你⽤react有什么坑点？
第1次 ：2021-07-19 11:41 — 5分钟  1
第2次 ：2021-07-19 12:06 — 30分钟  1
第3次 ：2021-07-19 23:36 — 12小时  1
第4次 ：2021-07-20 11:36 — 1天  1
第5次 ：2021-07-21 11:36 — 2天
第6次 ：2021-07-23 11:36 — 4天
第7次 ：2021-07-26 11:36 — 7天
第8次 ：2021-08-03 11:36 — 15天
1. JSX做表达式判断时候，需要强转为boolean类型(!!b)
  
2. 尽量不要在 componentWillReviceProps ⾥使⽤ setState，如果⼀定要使⽤，那么需要判断结束条
件，不然会出现⽆限重渲染，导致⻚⾯崩溃。(实际不是componentWillReviceProps会⽆限重渲染，⽽
是componentDidUpdate)

3. 给组件添加ref时候，尽量不要使⽤匿名函数，因为当组件更新的时候，匿名函数会被当做新的prop
处理，让ref属性接受到新函数的时候，react内部会先清空ref，也就是会以null为回调参数先执⾏⼀次
ref这个props，然后在以该组件的实例执⾏⼀次ref，所以⽤匿名函数做ref的时候，有的时候去ref赋值
后的属性会取到null

4. 遍历⼦节点的时候，不要⽤ index 作为组件的 key 进⾏传⼊。

### 怎么去设计⼀个组件封装
第1次 ：2021-07-19 11:42 — 5分钟  1
第2次 ：2021-07-19 12:07 — 30分钟  1
第3次 ：2021-07-19 23:37 — 12小时  1
第4次 ：2021-07-20 11:37 — 1天  1
第5次 ：2021-07-21 11:37 — 2天
第6次 ：2021-07-23 11:37 — 4天
第7次 ：2021-07-26 11:37 — 7天
第8次 ：2021-08-03 11:37 — 15天
* 组件封装的⽬的是为了重⽤，提⾼开发效率和代码质量
* 低耦合，单⼀职责，可复⽤性，可维护性

### react 的虚拟dom是怎么实现的
第1次 ：2021-07-19 11:43 — 5分钟  1
第2次 ：2021-07-19 12:08 — 30分钟  1 
第3次 ：2021-07-19 23:38 — 12小时  1
第4次 ：2021-07-20 11:38 — 1天  1
第5次 ：2021-07-21 11:38 — 2天
第6次 ：2021-07-23 11:38 — 4天
第7次 ：2021-07-26 11:38 — 7天
第8次 ：2021-08-03 11:38 — 15天

⾸先说说为什么要使⽤Virturl DOM，因为操作真实DOM的耗费的性能代价太⾼，所以react内部使⽤js
实现了⼀套dom结构，在每次操作在和真实dom之前，使⽤实现好的diff算法，对虚拟dom进⾏⽐较，
递归找出有变化的dom节点，然后对其进⾏更新操作。为了实现虚拟DOM，我们需要把每⼀种节点类
型抽象成对象，每⼀种节点类型有⾃⼰的属性，也就是prop，每次进⾏diff的时候，react会先⽐较该节
点类型，假如节点类型不⼀样，那么react会直接删除该节点，然后直接创建新的节点插⼊到其中，假如
节点类型⼀样，那么会⽐较prop是否有更新，假如有prop不⼀样，那么react会判定该节点有更新，那
么重渲染该节点，然后在对其⼦节点进⾏⽐较，⼀层⼀层往下，直到没有⼦节点。

### react hooks 原理是什么？
第1次 ：2021-07-19 11:42 — 5分钟  1
第2次 ：2021-07-19 12:07 — 30分钟  1
第3次 ：2021-07-19 23:37 — 12小时  1
第4次 ：2021-07-20 11:37 — 1天   1
第5次 ：2021-07-21 11:37 — 2天
第6次 ：2021-07-23 11:37 — 4天
第7次 ：2021-07-26 11:37 — 7天
第8次 ：2021-08-03 11:37 — 15天

hooks 是⽤闭包实现的，因为纯函数不能记住状态，只能通过闭包来实现。

### useState 中的状态是怎么存储的？
第1次 ：2021-07-19 11:50 — 5分钟
第2次 ：2021-07-19 12:15 — 30分钟  1
第3次 ：2021-07-19 23:45 — 12小时  1
第4次 ：2021-07-20 11:45 — 1天  1
第5次 ：2021-07-21 11:45 — 2天
第6次 ：2021-07-23 11:45 — 4天
第7次 ：2021-07-26 11:45 — 7天
第8次 ：2021-08-03 11:45 — 15天

通过单向链表，fiber tree 就是⼀个单向链表的树形结构

### 如何遍历⼀个dom树
第1次 ：2021-07-19 14:07 — 5分钟
第2次 ：2021-07-19 14:32 — 30分钟
第3次 ：2021-07-20 02:02 — 12小时  1
第4次 ：2021-07-20 14:02 — 1天
第5次 ：2021-07-21 14:02 — 2天
第6次 ：2021-07-23 14:02 — 4天
第7次 ：2021-07-26 14:02 — 7天
第8次 ：2021-08-03 14:02 — 15天
```JavaScript
function traversal(node) {
 //对node的处理
 if (node && node.nodeType === 1) {
 console.log(node.tagName);
 }
 var i = 0,
 childNodes = node.childNodes,
 item;
 for (; i < childNodes.length; i++) {
 item = childNodes[i];
 if (item.nodeType === 1) {
 //递归先序遍历⼦节点
 traversal(item);
 }
 }
}
```