### 宏任务


页面中的大部分任务都是在主线程上执行的，这些任务包括了：
* 渲染事件（如解析DOM、计算布局、绘制）；
* 用户交互事件
* JavaScript脚本执行事件
* 网络请求完成、文件读写完成事件

为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个for循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。

整体代码script、setTimeout、setInterval、setImmediate

### 微任务


异步回调的概念，其主要有俩种方式。
第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。

第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。

微任务就是一个需要异步执行的函数，执行事件是在主函数执行结束之后、当前宏任务结束之前。

产生微任务有俩种方式：

第一种方式是使用MutationObserver监控某个DOM节点，然后再通过JavaScript来修改这个节点，或者为这个节点添加、删除部分子节点，当DOM节点发生变化时，就会产生DOM变化记录的微任务。

第二种方式是使用Promise，当调用Promise.resolve()或者Promise.reject()的时候，也会产生微任务。

通过DOM节点变化产生的微任务或者使用Promise产生的微任务都会被JavaScript引擎按照顺序来保存到微任务队列中

通常情况下，在当前宏任务中的JavaScript快执行完成时，也就在JavaScript引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。

如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8引擎一直循环执行微任务队列中的任务，知道队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。

原生promise中then方法、process.nextTick、MutationObserver

微任务先于宏任务执行 如果宏任务中有微任务 会先执行完微任务再执行宏任务

### DOM Tree是如何构建的？
转码：浏览器将接收到的二进制数据按照指定编码格式转化成HTML字符串
生成Tokens:之后开始parser，浏览器会将HTML字符串解析成Tokens
构建Nodes:对Node添加特定的属性，通过指针确定Node的父、子、兄弟关系和所属treeScope
生成DOM Tree:通过node包含的指针确定的关系构建出dom

### 什么是同源策略？

域名、协议、端口号相同

### 浏览器缓存
memory cache  指内存中的缓存 是响应速度最快的一种缓存 缺点是缓存时间短，关闭页面就不存在了
service worker cache 是一种独立于主线程之外的javascript线程。可以用来实现离线缓存、消息推送以及网络代理等功能
disk cache 硬盘缓存
push cache 推送缓存 是http2中的内容，仅存在于会话阶段

### osi7层
物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

### 常见的浏览器内核有哪些？
chrome blink webkit
firefox gecko
safari webkit
edge edgeHTML
IE trident
phantomJS webkit

### 缓存策略
强缓存
  强缓存是利用http头中的expires和cache-control俩个字段来控制的
  expires是一个时间戳、cache-control是一个时间长度
协商缓存
  协商缓存依赖于服务端与浏览器之间的通信
  last-modified和etag
  last-modified是一个时间戳
  etag是由服务器为每个资源生成的唯一标识字符串

### 如何实现跨域？
  jsonp
  cors
  nginx 反向代理
    所有的客户端的请求都必须经过nginx的处理，nginx作为代理服务器再将请求转发
  window.name
  document.domain 二级域名相同的情况下
  postMessage+iframe