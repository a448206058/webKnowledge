### promise
promise规范
1. 只有一个then方法，没有catch、race、all等方法，甚至没有构造函数
2. then方法返回一个新的promise
3. 不同promise的实现需要可以相互调用(interoperable)
4. promise的初始状态为pending，它可以由此状态转换为fulfilled或者rejected,一旦状态确定，就不可以再次转换为其他状态，状态确定的过程成为settle

可以把promise看成一个状态机。初始是pending状态，可以通过函数resolve和reject，将状态转变为resolved或者rejected状态，状态一旦改变就不能再次变化

promiseA+规范
promise表示一个异步操作的最终结果。和一个promise进行交互的主要方式是通过它的then方法，该方法注册回调要么接收一个promise的最终值，要么接收promise为什么不能被满足的原因。

这个规范详细描述了then方法的行为，提供了一个可交互操作的基础，所有的符合promise/A+规范的promise都可以依靠该基础来实现。

promiseA+规范没有处理如何创建、满足或拒绝promise，而是选择去专注于提供一个可交互操作的then方法。

```JavaScript
// 三种状态
const PENDING = "pending";
const RESOLVED = "resolved";
const REJECTED = "rejected";

// promise 接收一个函数参数，该函数会立即执行
function MyPromise(fn) {
    let _this = this;
    _this.currentState = PENDING;
    _this.value = undefined;
    // 用于保存then 中的回调，只有当promise
    // 状态为pending时才会缓存，并且每个实例至多缓存一个
    _this.resolvedCallbacks = [];
    _this.rejectedCallbacks = [];

    _this.resolve = function (value) {
        if (value instanceof MyPromise) {
            // 如果value是个Promise，递归执行
            return value.then(_this.resolve, _this.reject)
        }
        setTimeout(() => { // 异步执行，保证执行顺序
            if (_this.currentState === PENDING) {
                _this.currentState = RESOLVED;
                _this.value = value;
                _this.resolvedCallbacks.forEach(cb => cb());
            }
        })
    };

    _this.reject = function (reason) {
        setTimeout(() => {
            if (_this.currentState === PENDING) {
                _this.currentState = REJECTED;
                _this.value = reason;
                _this.rejectedCallbacks.forEach(cb => cb());
            }
        })
    }

    try {
        fn(_this.resolve, _this.reject)
    } catch(e) {
        _this.reject(e)
    }
}

MyPromise.prototype.then = function (onResolved, onRejected) {
    var self = this;
    var promise2;
    onResolved = typeof onResolved === 'function' ? onResolved : v => v;
    onRejected = typeof onRejected === 'function' ? onRejected : r => throw r;

    if (self.currentState === RESOLVED) {
        return (promise2 = new MyPromise(function (resolve, reject) {
            setTimeout(function () {
                try {
                    var x = onResolved(self.value);
                    resolutionProcedure(promise2, x resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            })
        }))
    }

    if (self.currentState === REJECTED) {
        return (promise2 = new MyPromise(function (resolve, reject) {
            setTimeout(function () {
                try {
                    var x = onRejected(self.value)
                    resolutionProcedure(promise2, x, resolve, reject);
                } catch (reason) {
                    reject(reason);
                }
            })
        }))
    }

    if (self.currentState === PENDING) {
        return (promise2 = new MyPromise(function (resolve, reject){
            self.resolvedCallbacks.push(function() {
                try {
                    var x = onResolved(self.value)
                    resolutionProcedure(promise2, x, resolve, reject);
                } catch (r) {
                    reject(r);
                }
            });

            self.rejectedCallbacks.push(function () {
                try {
                    var x = onRejected(self.value);
                    resolutionProcedure(promise2, x, resolve, reject);
                } catch (r) {
                    reject(r);
                }
            })
        }))
    }
}

function resolutionProcedure(promise2, x, resolve, reject) {
    if (promise2 === x) {
        return reject(new TypeError("Error"))
    }
    if (x instanceof MyPromise) {
        if (x.currentState === PENDING) {
            x.then(function (value) {
                resolutionProcedure(promise2, value, resolve, reject);
            }, reject)
        } else {
            x.then(resolve, reject);
        }
        return;
    }
    let called = false;
    
    if (x !== null && (typeof x === "object" || typeof x === "function")) {
        try {
            let then = x.then;
            if (typeof then === "function") {
                then.call(
                    x,
                    y => {
                        if (called) return;
                        called = true;
                        resolutionProcedure(promise2, y, resolve, reject);
                    },
                    e => {
                        if (called) return;
                        called = true;
                        reject(e);
                    }
                )
            } else {
                resolve(x);
            }
        } catch (e) {
            if (called) return;
            called = true;
            reject(e);
        }
    } else {
        resolve(x);
    }
}
```

简单实现
```JavaScript
function Promise(fn) {
    this.cbs = [];
    const resolve = (value) => {
        setTimeout(() => {
            this.data = value;
            this.cbs.forEach((cb) => cb(value))
        })
    }
    fn(resolve);
}

Promise.prototype.then = function (onResolved) {
    return new Promise((resolve) => {
        this.cbs.push(() => {
            const res = onResolved(this.data)
            if (res instanceof Promise) {
                res.then(resolve)
            } else {
                resolve(res)
            }
        })
    })
}
```
Promise.all(iterable)
  等待所有的promises转变成resolved或者rejected
   如果返回promise resolves,它是resolved用一个从resolved promises的值的数组联合，按照多个可迭代的promises中定义的顺序。
     如果是rejects,它是用一个reason从第一个可迭代的rejected的promise返回
 ```JavaScript
   Promise.all = function(ps) {
       let resolve
       let reject
       const promise = new Promise((r, j) => {
           resolve = r
           reject = j
       })
       let fulfilledCount = 0
       let index = 0
       const ret = []
       const wrapFulfilled = i => {
           return val => {
               fulfilledCount += 1
               ret[i] = val
               if(fulfilledCount >= index){
                   resolve(ret)
               }
           }
       }
       const wrapRejected = i => {
           return err => {
               reject(er)
           }
       }
       for (let p of ps) {
           Promise.resolve(p).then(wrapFulfilled(index), wrapRejected(index))
           index += 1
       }
       return promise
   }
```
Promise.allSettled(iterable)
 等待所有的promises已经被解决了（每一个可能是resolve或者reject)
   返回一个在所有提供的promises都变成了resolved或者rejected的promise,用一个数组对象来描述每个promise的结果
 ```JavaScript
   Promise.allSettled = function(ps) {
       let resolve
       let reject
       const promise = new Promise((r, j) => {
           resolve = r
           reject = j
       })
       let finishedCount = 0
       let index = 0;
       const ret = [];
       const wrapFulfilled = i => {
           return val => {
               finishedCount += 1
               ret[i] = {
                   status: 'fulfilled',
                   value: val
               }
               if (finishedCount >= index) {
                   resolve(ret)
               }
           }
       }
       const wrapRejected = i => {
           return err => {
               finishedCount += 1
               ret[i] = {
                   status: 'rejected',
                   value: err
               }
               if (finishedCount >= index) {
                   resolve(ret)
               }
           }
       }
       for (let p of ps) {
           Promise.resolve(p).then(wrapFulfilled(index), wrapRejected(index))
           index += 1
       }
       return promise
   }
```

### Promise.any(iterable)
获取Promise对象的可迭代的，一旦迭代器中的一个promises变成了fulfills，返回单一的带value的resolves状态的promise
   只要其中的一个promise 成功，就返回那个已经成功的promise。如果可迭代对象中没有一个promise成功（即所有的promises都失败/拒绝），
   就返回一个失败的promise和AggregateError类型的实例，它是Error的一个子类，用于把单一的错误集合在一起。
   本质上，这个方法和Promise.all()是相反的
```JavaScript
   Promise.any = function(ps) {
       let resolve
       let reject
       const promise = new Promise((r, j) => {
           resolve = r
           reject = j
       })
       let errCount = 0
       let pCount = 0
       for (let p of ps) {
           pCount += 1
           Promise.resolve(p).then(
               val => resolve(val),
               err => {
                   errCount += 1
                   if (errCount >= pCount) {
                       reject(new AggregateError('All promises were rejected'))
                   }
               }
           )
       }
       return promise
   }
```