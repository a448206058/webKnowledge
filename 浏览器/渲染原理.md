https://mp.weixin.qq.com/s/QVfBgLXHKLQS-RkRi-cf4w

https://mp.weixin.qq.com/s/Qkw92nC5PddIwHCoi89zhw

## DOM树：JavaScript是如何影响DOM树构建的？
### 什么是DOM？
从网络传给渲染引擎的HTML文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是DOM。DOM提供了对HTML文档结构化的表述。在渲染引擎中，DOM有三个层面的作用。
* 从页面的视角来看，DOM是生成页面的基础数据结构
* 从JavaScript脚本视角来看，DOM提供给JavaScript脚本操作的接口，通过这套接口，JavaScript可以对DOM结构进行访问，从而改变文档的结构、样式和内容。
* 从安全视角来看，DOM是一道安全防护线，一些不安全的内容在DOM解析阶段就被拒之门外来。
简而言之，DOM是表述HTML的内部数据结构，它会将Web页面和JavaScript脚本链接起来，并过滤一些不安全的内容。

### DOM树如何生成
在渲染引擎内部，有一个叫**HTML解析器（HTML Parser)**的模块，它的职责就是负责将HTML字节流转换为DOM结构。

HTML解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载来多少数据，HTML解析起便解析多少数据。

网络进程和渲染进程之间会建立一个共享数据的管道

字节流转换为DOM需要三个阶段
第一个阶段，通过分词器将字节流转换为Token
第二个和第三个阶段是同步进行的，需要将Token解析为DOM节点，并将DOM节点添加到DOM树中。

HTML解析器维护来一个Token栈结构，该Token栈主要用来计算节点之间的父子关系，在第一个阶段生成的Token会被按照顺序压到这个栈中。
* 如果压入到栈中的是StartTag Token，HTML解析器会为该Token创建一个DOM节点，然后将该节点加入到DOM树中，它的父节点就是栈中相邻的那个元素生成的节点。

* 如果分词器解析出来的是文本Token，那么会生成一个文本节点，然后将该节点加入到DOM树中，文本Token是不需要压入到栈中，它的父节点就是当前栈顶Token所对应的DOM节点。

* 如果分词器解析出来的是EndTag标签，HTML解析器会查看Token栈顶的元素是否是StarTagDiv,如果是，就将startTag div从栈中弹出，表示该div元素解析完成。

HTML解析起开始工作时，会默认创建了一个根为document的空DOM结构

### JavaScript是如何影响DOM生成的
JavaScript文件的下载过程会阻塞dom解析
使用CDN来加速JavaScript文件的加载，压缩JavaScript文件的体积。

## 渲染流水线：CSS如何影响首次加载时的白屏时间？
当渲染进程接收HTML文件字节流时，会先开启一个**预解析线程**，如果遇到JavaScript文件或者CSS文件，那么预解析线程会提前下载这些数据。

CSSOM具有俩个作用，第一个时提供给JavaScript操作样式表的能力，第二个是为布局树的合成提供基础的样式信息。

解析HTML、下载CSS、下载JavaScript、生成CSSOM、执行JavaScript、生成布局树、绘制页面一系列操作

通常情况下的瓶颈主要体现在下载CSS文件、下载JavaScript文件和执行JavaScript
缩短白屏时长，有以下策略：
* 通过内联JavaScript、内联CSS来移除这俩种类型的文件下载，这样获取到HTML文件之后就可以直接开始渲染流程来。
* 但并不是所有的场合都适合内联，那么还可以尽量减少我呢就爱你大小，比如通过webpack等工具移除一些不必要的注释，并压缩JavaScript文件
* 还可以将一些不需要在解析HTML阶段使用的JavaScript标记上sync或者defer.
* 对于大的CSS文件，可以通过媒体查询属性，将其拆分为多个不同用途的CSS文件，这样只有在特定的场景下才会加载特定的CSS文件。

## 分层和合成机制：为什么CSS动画比JavaScript高效？
### 显示器是怎么显示图像的
每个显示器都有固定的刷新频率，通常是60HZ，也就是每秒更新60张图片，更新的图片都来自于显卡中一个叫前缓冲区的地方，显示器所做的任务很简单，就是每秒固定读取60次前缓冲区中的图像，并将读取的图像显示到显示器上。

显卡的职责就是合成新的图像，并将图像保存到后缓冲区，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区呼唤。

### 帧 vs 帧率
我们把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新率多少帧称为帧率，比如滚动过程中1秒更新了60帧，那么帧率就是60Hz（或者60FPS）

### 分层与合成
为了提升每帧的渲染效率，Chrome引入了分层与合成的机制。

将素材分解为多个图层的操作称为分层，最后将这些图层合并到一起的操作称为合成。所以，分层和合成通常是一起使用的。

在Chrome的渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。

层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。

合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。

### 分块
如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率

合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。

### 如何利用分层技术优化代码
使用will-change: transform, opacity;

## 页面性能：如何系统地优化页面？
通常一个页面生存周期有三个阶段：加载阶段、交互阶段和关闭阶段
* 加载阶段，是指从发出请求到渲染除完整页面的过程，影响到这个阶段的主要因素有网络和JavaScript脚本
* 交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是JavaScript脚本
* 关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作

### 加载阶段
JavaScript、首次请求的HTML资源文件、CSS文件是会阻塞首次渲染的，因为在构建DOM的过程中需要HTML和JavaScript文件，在构造渲染树的过程中需要用到CSS文件。

我们把这些能阻塞网页首次渲染的资源称为关键资源
第一个是关键资源个数
第二个是关键资源大小
第三个是请求关键资源需要多少个RTT(Round Trip Time)
RTT就是这里的往返时延长。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。通常1个HTTP的数据包在14kb左右，所以1个0.1M的页面就需要拆分成8个包来传输来，也就是说需要8个RTT。

**总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的RTT次数**
* 如何减少关键资源的个数？一种方式是可以将JavaScript和CSS改成内敛的形式，比如上图的JavaScript和CSS，若都改成内联模式，那么关键资源的个数就由3个减少到了1个。另一种方式，如果JavaScript代码没有DOM或者CSSOM的操作，则可以改成sync或者deffer属性；同样对于CSS,如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。当JavaScript标签加上了sync或者defer、CSSLink属性之前加上了取消阻止显现的标志后，它们就变成了非关键资源了。

* 如何减少关键资源的大小？可以压缩CSS和JavaScript资源，移除HTML、CSS、JavaScript文件中一些注释内容，也可以通过前面讲的取消CSS或者JavaScript中关键资源的方式。

* 如何减少关键资源RTT的次数？可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。除此之外，还可以使用CDN来减少每次RTT时长。

### 交互阶段
1. 减少JavaScript脚本执行事件
* 一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。
* 咯ing一种是采用Web Workers。在Web Workers是无法通过JavaScript来访问DOM的，所以我们可以把一些和DOM操作无关且耗时的任务放到Web Workers中去执行。

2. 避免强制同步布局
所谓强制同步布局，是指JavaScript强制将计算样式和布局操作提前到当前的任务中。

3. 避免布局抖动

4. 合理利用CSS合成动画

5. 避免频繁的垃圾回收

## 虚拟DOM和实际的DOM有何不同？

### 什么是虚拟DOM
要做哪些事情
* 将页面改变的内容应用到虚拟DOM上，而不是直接应用到DOM上
* 变化被应用到虚拟DOM上，虚拟DOM并不急着去渲染页面，而仅仅是调整虚拟DOM的内部状态，这样操作虚拟DOM的代价就变得非常轻了
* 在虚拟DOM收集到足够的改变时，再把这些变化一次性应用到真实的DOM上

* **创建阶段** 首先依据JSX和基础数据创建出来虚拟DOM，它反映了真实的DOM树的结构。然后由虚拟DOM树创建出真实DOM树，真实的DOM数生成完后，再触发渲染流水线往屏幕输出页面。
* **更新阶段** 如果数据发生了改变，那么久需要根据新的数据创建一个新的虚拟DOM树；然后React比较俩个树，找出变化的地方，并把变化的地方一次性更新到真实的DOM树上；最后渲染引擎更新渲染流水线，并生成新的页面。

可以吧虚拟DOM看成是MVC的视图部分，其控制器和模型都是由Redux提供的。
* 控制器是用来监控DOM的变化，一旦DOM发生变化，控制器便会通知模型，让其更新数据；
* 模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化
* 视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟DOM
* 新的虚拟DOM生成好之后，就需要与之前的虚拟DOM进行比较，找出变化的节点
* 比较出变化的节点之后，React将变化的虚拟节点应用到DOM上，这样就会触发DOM节点的更新
* DOM节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新。

## 渐进式网页应用（PWA）
它是一套理念，渐进式增强Web的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离

### Web应用 VS 本地应用
相对于本地应用，Web页面到底缺少了什么？
* 首先，Web应用缺少离线使用能力
* 其次，Web应用还缺少了消息推送的能力
* 最后，Web应用缺少一级入口，也就是将Web应用安装到桌面

PWA解决：
**通过引入Service Worker来试着解决离线存储和消息推送的问题，通过引入manifest.json来解决一级入口的问题。**

### 什么是Service Worker
主要思想是**在页面和网络之间增加一个拦截器，用来缓存和拦截请求**

Service Worker设计思路
1. 架构
Web Worker其实就是在渲染进程中开启的一个新线程，它的生命周期是和页面关联的。
"让其运行在主线程之外"就是Service Worker来自Web Worker的一个核心思想

2. 消息推送
消息推送也是基于Service Worker来实现的。

3. 安全 https

##  WebComponent: 像搭积木一样构建Web应用
什么是组件化：对内高内聚，对外低耦合。对内各个元素彼此紧密结合、相互依赖，对外和其他组件的联系最少且接口简单。

### WebComponent组件化开发
提供了对局部视图封装能力，可以让DOM、CSSOM和JavaScript运行在局部环境中，这样就使得局部的CSS和DOM不会影响到全局

首先，使用template属性来创建模板。利用DOM可以查找到模板的内容，但是模板元素是不会被渲染到页面上的。

其次，我们需要创建一个GeekBang的类，在该类的构造函数中要完成三件事：
1. 查找模板内容；
2. 创建影子DOM；
3. 再将模板添加到影子DOM上。

最后，可以像正常使用HTML元素一样使用该元素

### 浏览器如何实现影子DOM
1. 影子DOM中的元素对于整个网页是不可见的；
2. 影子DOM的CSS不会影响到整个网页的CSSOM,影子DOM内部的CSS只对内部的元素起作用

