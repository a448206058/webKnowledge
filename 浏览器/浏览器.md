## Chrome架构

### 什么是并行处理
并行处理就是采用多线程处理，使用并行处理能大大提升性能

### 线程 VS 进程
多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。

一个进程就是一个程序的运行实例。

线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

进程和线程之间的关系特点：
1. 进程中任意一线程执行出错，都会导致整个进程崩溃。

2. 线程之间共享进程中的数据。

3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。

4. 进程之间的内容相互隔离。

### 单进程浏览器时代
单进程浏览器是指浏览器所有功能模块都是运行在同一个进程里。

这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。

如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。

### 不稳定
插件和渲染引擎模块是不稳定的，本身的崩溃会导致整个浏览器崩溃

### 不流畅
脚本、插件、页面的内存泄露都会让单进程变慢

### 不安全
插件自身或者脚本可以通过浏览器漏洞来获取系统权限来对电脑做一些恶意的事情，引发安全问题

### 多进程浏览器时代
不稳定：进程是相互隔离的，当一个页面或者插件崩溃，影响到的仅仅是当前的页面进程或者插件进程

不流畅：影响到的是当前渲染页面

不安全：采用多进程架构的额外好处就是可以使用安全沙箱，Chrome把插件进程和渲染进程锁在沙箱里面

### Chrome进程架构
1个浏览器主进程（Browser Process）
>主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。

多个渲染进程（Render Process）
>核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排版引擎BLink和JavaScript引擎V8都是运行在该进程中，Chrome会为每个Tab标签创建一个渲染进程，处于安全考虑，渲染进程都是运行在沙箱模式下。

1个GPU进程（GPU Process）
>绘制UI界面

1个网络进程（NewWork Process）
>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器里面

多个插件进程（Plugin Process）
>主要负责插件的运行

### 未来面向服务架构
Chrome最终要把UI、数据库、文件、设备、网络等模块重构为基础服务，类似于操作系统底层服务

## TCP协议：如何保证页面文件能被完整送达浏览器？
**FP（First Paint）**指从页面加载到首次开始绘制的时长。
影响FP指标的一个重要因素是网络加载速度。

在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大概率丢失或者出错。**如何保证页面文件能被完整地送达浏览器？**

互联网，实际上是一套理念和协议组成的体系架构。

IP：把数据包送达目的地主机
计算机的地址就称为IP地址，访问任何网站实际上知识你的计算机向另外一台计算机请求信息。

UDP：把数据包送达应用程序
IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包分发给正确的程序。

UDP不能保证数据可靠性，但是传输速度非常快，所以UDP会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。

TCP：把数据完整地送达应用程序
TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议

UDP有俩个问题
* 数据包在传输过程中容易丢失
* UDP协议并不知道如何组装数据包，从而把这些数据包还原成完整的文件

TCP解决
* 对于数据包丢失的情况，TCP提供重传机制；
* TCP引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件

一个完整的TCP连接的生命周期包括了
**建立连接** 三次握手
**传输数据** 接收端需要对每个数据包进行确认操作
**断开连接** 四次挥手



HTTP协议是建立再TCP连接基础之上的。**HTTP是一种允许浏览器向服务器获取资源的协议，是Web的基础，HTTP也是浏览器使用最广的协议。**

### 浏览器发起HTTP请求流程

1. 构建请求
首先，浏览器构建请求行信息，构建好后，浏览器准备发起网络请求
```
GET /index.html HTTP1.1
```

2. 查找缓存
浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。

3. 准备IP地址和端口
浏览器HTTP协议作为应用层协议，用来封装请求的文本协议；使用TCP/IP作传输层协议将它发到网络上，所以在HTTP工作开始之前，浏览器需要通过TCP与服务器建立连接。也就是说HTTP的内容是通过TCP的传输数据阶段来实现的。

**DNS**（Domain Name System）**域名系统**，负责把域名和IP地址做一一映射关系。

第一步浏览器会请求DNS返回域名对应的IP。浏览器还提供了DNS数据缓存服务。如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。

4. 等待TCP队列
Chrome有个机制，同一个域名同时最多只能建立6个TCP连接，如果在同一个域名下同时又10个请求发生，那么其中4个请求会进入排队等待状态，直至进行中的请求完成。

5. 建立TCP连接

6. 发送HTTP请求
首先浏览器会向服务器发送请求行，包括了请求方法、请求URI（Uniform Resource Identifier）和HTTP版本协议

### 服务器端处理HTTP请求流程
1. 返回请求

2. 断开连接
通常请求下，一旦服务器向客户端返沪了请求数据，它就要关闭TCP连接。不过如果浏览器或者服务器在其头信息中加入了：
```
Connection:Keep-Alive
```
那么TCP连接在发送后仍然保持打开状态，这样浏览器就可以继续通过同一个TCP连接发送请求。
**TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度

3. 重定向

## 为什么很多站点第二次打开速度会很快？
DNS缓存和页面资源缓存
因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS数据也被浏览器缓存了，这又省去了DNS查询环节。

### 浏览器中的HTTP请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备IP和端口、
等待TCP队列、建立TCP连接、发起HTTP请求、服务器处理请求、服务器返回请求和断开连接

### 从输入URL到页面展示，这中间发生了什么？

* 浏览器进程主要负责用户交互、子进程管理和文件储存等功能。
* 网络进程是面向渲染进程和浏览器进程等提供网络下载功能。
* 渲染进程的主要职责是把网络下载的HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。

* 首先，用户从浏览器进程里**输入请求信息**；
    
    在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的URL

* 然后，网络进程**发起URL请求**；

    浏览器进程会通过进程间通信（IPC）把URL请求发送至网络进程，网络进程接收到URL请求后，会在这里发起真正的URL请求流程。

* 服务器响应URL请求之后，浏览器进程就又要开始**准备渲染进程**了；

    渲染进程的策略
    通常情况下，打开新的页面都会使用单独的渲染进程；
    如果从A页面打开B页面，且A和B都属于同一站点的话，那么B页面复用A页面的渲染进程；如果是其他情况，浏览器进程则会为B创建一个新的渲染进程。

* 渲染进程准备好之后，需要先向渲染进程提交页面数据，我们称之为**提交文档**阶段；

    文档是指URL请求的响应体数据
    提交文档的消息是由浏览器进程发出的，渲染进程接收到提交文档的消息后，会和网络进程建立传输数据的管道。
    等文档数据传输完成之后，渲染进程会返回确认提交的消息给浏览器进程
    浏览器进程在收到确认提交的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面。

* 渲染进程接收完文档信息之后，便开始**解析页面和加载子资源**，完成页面的渲染

**用户发出URL请求到页面开始解析的这个过程，就叫做导航**

* 服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断
* Chrome默认采用每个标签对应一个渲染进程，但是如果俩个页面属于同一站点，那这俩个标签会使用同一个渲染进程
* 浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的所以阶段


## 渲染流程：HTML、CSS和JavaScript是如何变成页面的？
HTML 超文本 标记语言
CSS 层叠样式表
JS JavaScript

* 构建DOM树：将HTML用HTML解析器解析输出树状结构的DOM

* 样式计算：1.将CSS文本转换为浏览器可以理解的结构——styleSheets；2.转换样式表中的属性值，使其标准化；3.计算出DOM树中每个节点的具体样式

* 布局阶段：计算出DOM树中可见元素的几何位置，这个计算过程叫布局；

    1.创建布局树：
        遍历DOM树中所有可见节点，并把这些节点加到布局中；
        而不可见的节点会被布局树忽略掉
    2.布局计算

* 分层：渲染引擎还需要为特定的节点生成专用的图层，并生成一颗对应的图层树；浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。

    1.拥有层叠上下文属性的元素会被提升为单独的一层（fixed,z-index,filter:blue,opacity）
    2.需要剪裁的地方也会被创建为图层

* 图层绘制：渲染引擎会把图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表

* 栅格化操作：绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程完成的。合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是将图块转换为位图。

1. 渲染进程将HTML内容转换为能够读懂的DOM树结构。
2. 渲染引擎将CSS样式表转换为浏览器可以理解的styleSheets，计算出DOM节点的样式
3. 创建布局树，并计算元素的布局信息
4. 对布局树进行分层，并生成分层树
5. 为每个图层生成绘制列表，并将其提交到合成线程
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图
7. 合成线程发送绘制图块命令DrawQuad给浏览器进程
8. 浏览器进程根据DrawQuad消息生成页面，并显示到显示器上。

## HTTP性能优化
在诞生之初的HTTP/0.9因为需求简单，所以和服务器之间的通信过程也相对简单

核心的需求就是需要支持多种类型的文件下载，为此HTTP/1.0中引入了请求头和响应头。在支持多种类型文件下载的基础之上，HTTP/1.0还提供了Cache机制、用户代理、状态码等一些基础信息。

HTTP/1.1增加了持久连接方法来提升连接效率，同时还尝试使用管线化技术提升效率。除此之外，HTTP/1.1还引入了Cookie、虚拟主机的支持、对动态内容的支持等特性。

虽然HTTP/1.1在HTTP/1.0的基础之上做了大量的优化，但是由于一些效率问题始终很难解决，所以最终还是被HTTP/2所取代。


## HTTP2:如何提升网络速度？
HTTP1.1 最核心的有如下三种方式：
1. 增加了持久连接；
2. 浏览器为每个域名最多同时维护6个TCP持久连接；
3. 使用CDN的实现域名分片机制。

HTTP/1.1对带宽的利用率并不理想，这也是HTTP/1.1的一个核心问题。

带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。
主要是由以下三个原因导致的
* 第一个原因，TCP的慢启动
* 第二个原因，同时开启了多条TCP连接，那么这些连接会竞争固定的带宽。
* 第三个原因，HTTP/1.1队头阻塞问题

### HTTP/2的多路复用
要想办法规避TCP的慢启动和TCP连接之间的竞争问题。HTTP/2的思路就是一个域名只使用TCP长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免来多个TCP连接竞争带宽所带来的问题。

另外，就是对头阻塞的问题，等待请求玩橙后才能去请求下一个资源，这种方式无疑是最慢的，所以HTTP/2需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其它请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。

所以，HTTP/2的解决方案可以总结为：一个域名只使用一个TCP长连接和消除对头阻塞问题。

### 多路复用的实现
HTTP/2添加来一个二进制分帧层
* 首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是POST方法，那么还要有请求体。
* 这些数据经过二进制分帧处理之后，会被转换为一个个带有请求ID编号的帧，通过协议栈将这些帧发送给服务器。
* 服务器接收到所有帧之后，会将所有相同ID的帧合并为一条完整的请求信息。
* 服务器接收到所有帧之后，会将所有相同ID的帧合并为一条完整的请求信息。
* 然后服务器处理该条请求，并将处理的相应行、响应头和响应体分别发送至二进制分帧层。
* 同样，二进制分帧层会将这些响应数据转换为一个个带有请求ID编号的帧，经过协议栈发送给浏览器。
* 浏览器接收到响应帧之后，会根据ID编号将帧的数据提交给对应的请求

通过引入二进制分帧层，就实现了HTTP的多路复用技术

### HTTP/2其它特性
1. 可以设置请求的优先级
2. 服务器推送
3. 头部压缩

## HTTP3: 甩掉TCP、TLS的包袱，构建高效网络
### TCP的队头阻塞
在tcp传输过程中，由于单个数据包的丢失而造成的阻塞称为TCP上的队头阻塞。

### TCP建立连接的延时

### TCP协议僵化
第一个是中间设备的僵化（路由器、防火墙、NAT、交换机、操作系统）

### QUIC协议
基于UDP实现了类似于TCP的多路数据流、传输可靠性等功能，我们把这套功能称为QUIC协议。

* 实现了类似TCP的流量控制、传输可靠性的功能
* 集成了TLS加密功能
* 实现了HTTP/2中的多路复用功能
* 实现了快速握手功能

## HTTPS：让数据传输更安全
使用HTTP传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为**中间人攻击**

### 再HTTP协议栈中引入安全层
从HTTP协议栈层面来看，我们可以在TCP和HTTP之间插入一个安全层，所有经过安全层的数据都会被加密或者解密

通常HTTP直接和TCP通信，HTTPS则先和安全层通信，然后安全层再和TCP层通信。也就是说HTTPS所有的安全核心都在安全层，它不会影响到上面的HTTP协议，也不会影响到下面的TCP/IP

安全层有俩个主要的职责：**对发起HTTP请求的数据进行加密操作**和**对接收到HTTP的内容进行解密操作**。

1. 对称加密传输（协商秘钥的过程容易被窃取）
2. 非对称加密传输（服务端用私钥加密的内容，可以通过它的公钥进行解密）
3. 非对称加密交换秘钥、对称加密传输内容（DNS劫持 如何保证服务器是可信的）
4. 引入CA权威机构保证服务器可信性。

* 在传输数据阶段使用对称加密，但是对称加密的密钥采用非对称加密来传输，引入数字证书，数字证书是由CA签名过的，所以浏览器能够验证该证书的可靠性。



