## 块级作用域

### 作用域（scope）
作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

在ES6之前，作用域只有俩种：全局作用域和函数作用域
* 全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期
* 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

* let、const 声明快级作用域：作用块内声明的变量不影响块外面的变量

块级作用域是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这俩者的结合，JavaScript引擎也就同时支持了变量提升和块级作用域了

## 作用域和闭包
### 作用域链
在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer

当一段代码使用了一个变量时，JavaScript引擎首先会在“当前的执行上下文”中查找该变量，如果在当前的变量环境中没有查找到，那么JavaScript引擎会继续在outer所指向的执行上下文中查找。我们把这个查找的链条称为作用域链

### 词法作用域
词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系

### 闭包
在JavaScript中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。

使用闭包的原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。

## this
执行上下文中包含了变量环境、词法环境、外部环境和this

this是和执行上下文绑定的
执行上下文主要分为三种——全局执行上下文、函数执行上下文和eval执行上下文

### 全局执行上下文中的this
全局执行上下文中的this是指向window对象的，这也是this和作用域的唯一交点，作用域链的最底端包含了window对象，全局执行上下文中的this也是指向window对象

### 函数执行上下文中的this
默认情况下也是指向window

### 改变this的指向
1. 通过call、apply
2. 通过对象调用方法设置：使用对象来调用其内部的一个方法，该方法的this是指向对象本身的。
在全局环境中调用一个函数，函数内部的this指向的是全局变量window
3. 通过构造函数中设置 new

### 总结
1. 当函数作为对象的方法调用时，函数中的this就是该读喜庆
2. 当函数被正常调用时，在严格模式下，this值是undefined，非严格模式下this指向的是全局对象window;
3. 嵌套函数中的this不会继承外层函数的this值

## 栈空间和堆空间
在使用之前就需要确认其变量数据类型的称为静态语言，把在运行过程中需要检查数据类型的语言称为动态语言。

支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。

### JavaScript的数据类型
JavaScript是一种弱类型的、动态的语言

JavaScript的数据类型一共有8种：Boolean、Null、Undefined、number、string、BigInt、symbol、Object

### 内存空间
代码空间、栈空间、堆空间

原生类型的数据值都是直接保存在栈中的，引用类型的值是存放在堆中的。

原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。

### 闭包
产生闭包的核心有俩步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。

## 垃圾回收
### 调用栈中的数据是如何回收的
JavaScript采用自动垃圾回收的策略，产生的垃圾数据都是由垃圾回收器来释放的

记录当前执行状态的指针（称为ESP）

JavaScript引擎会通过向下移动ESP来销毁该函数保存在栈中的执行上下文

### 堆中的数据是如何回收的
要回收堆中的垃圾数据，就需要用到JavaScript中的垃圾回收器了。

### 代际假说和分代收集
代际假说有俩个特点：
* 第一个是大部分对象在内存中存在的时间很短；
* 第二个是不死的对象，会活的更久。

在V8中会把堆分为新生代和老生代俩个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象

* 副垃圾回收器，主要负责新生代的垃圾回收
* 主垃圾回收器，主要负责老生代的垃圾回收

### 垃圾回收器的工作流程
1. 标记空间中活动对象和非活动对象
2. 回收非活动对象所占据的内存
3. 内存整理（可选）

### 副垃圾回收器
新生代中用Scavenge算法来处理。就是把新生代空间对半划分为俩个区域，一半是对象区域，一半是空闲区域

新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

垃圾清理阶段，会把存活的对象复制到空闲区域中，同时把这些对象有序地排列起来，所以这个复制过程，也就相当于完成来内存整理操作。

完成复制后，对象区域与空闲区域进行角色翻转，这样就完成来垃圾对象的回收操作。经过俩次垃圾回收依然还存活的对象，会被移动到老生区。这就是对象晋升策略

### 主垃圾回收器
采用标记-清除的算法进行垃圾回收的

### 全停顿
JavaScript是运行在主线程之上的，一旦执行垃圾回收算法，需要将正在执行的JavaScript脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿。

## V8是如何执行一段JavaScript代码的
### 编译器和解释器
编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留及其能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译来。

而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。

编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。

在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树来生成字节码，最后根据字节码来执行程序、输出结果

### V8是如何执行一段JavaScript代码的
1. 生成抽象语法树（AST)和执行上下文
Babel的工作原理就是先将ES6源码转换为AST，然后再将es6语法的AST转换为ES5语法的AST，最后利用ES5的AST生成JavaScript源代码。
ESLint检测流程也是需要将源码转换为AST，然后再利用AST来检查代码规范化的问题。

生成AST需要经过俩个阶段：
第一阶段是分词（tokenize)，又成词法分析，其作用是将一行行的源码拆解成一个个token。所谓token，指的是语法上不可能再分的、最小的单个字符或字符串。

第二阶段是解析（parse)，又称语法分析，其作用是将上一步生成的token数据，根据语法规则转化为AST。

2. 生成字节码
解释器Ignition，根据AST生成字节码
字节码就是介于AST和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。

3. 执行代码
解释器Ignition逐条解释执行
JIT编译器TurboFan一次编译热区代码

### JavaScript性能优化
1. 提升单词脚本的执行速度，避免JavaScript的长任务霸占主线程，这样可以使得页面快速响应交互；

2. 避免大的内联脚本，因为在解析HTML的过程中，解析和编译也会占用主线程；

3. 减少JavaScript文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。


## 消息队列和事件循环
消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。

通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果DOM有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。

等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为DOM变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。

## JavaScript面向对象
封装、继承以及多态
1. 封装：是一种通过接口抽象将具体实现包装并隐藏起来的方法
* 限制对对象内部组件直接访问的机制；
* 将数据和方法绑定起来，对外提供方法，从而改变对象状态的机制。

纯函数：函数不允许引用任何自由变量
函数的调用不允许改变其所属的上下文；
相同入参的函数调用一定能得到相同的返回值。

2. 继承：一个对象或者类能够自动保持另一个对象或者类的实现的一种机制。

3. 多态：指的是同样的接口，有着不同的实现。

## setTimeout是如何实现的？
浏览器页面是由消息队列和事件循环系统来驱动的

setTimeout是一个定时器，用来指定某个函数在多少毫秒之后执行

### 浏览器怎么实现setTimeout
* 首先，为了支持定时器的实现，浏览器增加了延时队列。
* 其次，由于消息队列排队和一些系统级别的限制，通过setTimeout设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。
* 最后，定时器使用过程中，还存在一些陷阱。

## XMLHttpRequest是怎么实现的？
是由浏览器的其他进程或者线程去执行，然后再将执行结果利用IPC的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中。

### 回调函数VS系统调用栈
将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。

回调函数是在主函数返回之前执行的，我们把这个回调过程称为同步回调。

回调函数在主函数外部执行的过程称为异步回调

## 交互设计和页面布局

### 单页面应用
用户打开一个页面，大部分操作都是在单个页面里面完成。SPA省去了页面跳转的突兀感受和等待时间，用户体验更加桌面化，操作迅速、切换无缝；

### 渐进式增强
渐进式增强，即Progressive Enhancement,强调的是可访问性，即允许不同能力的设备都能够访问网页的基本内容，使用网页的基本功能；但是，当用户使用更加现金的设备时，它能够给用户带来更强大的功能和更好的体验。

### 优雅降级

### 响应式布局
自适应性网页设计

## 宏任务和微任务
### 宏任务
页面中的大部分任务都是在主线程上执行的，这些任务包括了：
* 渲染事件（如解析DOM、计算布局、绘制）；
* 用户交互事件
* JavaScript脚本执行事件
* 网络请求完成、文件读写完成事件

为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个for循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。

### 微任务

异步回调的概念，其主要有俩种方式。
第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。

第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。

微任务就是一个需要异步执行的函数，执行事件是在主函数执行结束之后、当前宏任务结束之前。

产生微任务有俩种方式：

第一种方式是使用MutationObserver监控某个DOM节点，然后再通过JavaScript来修改这个节点，或者为这个节点添加、删除部分子节点，当DOM节点发生变化时，就会产生DOM变化记录的微任务。

第二种方式是使用Promise，当调用Promise.resolve()或者Promise.reject()的时候，也会产生微任务。

通过DOM节点变化产生的微任务或者使用Promise产生的微任务都会被JavaScript引擎按照顺序来保存到微任务队列中

通常情况下，在当前宏任务中的JavaScript快执行完成时，也就在JavaScript引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。

如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8引擎一直循环执行微任务队列中的任务，知道队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。

## 使用Promise

Promise主要通过以下俩步解决嵌套回调问题的
首先，Promise实现了回调函数的延时绑定

其次，需要将回调函数onResolve的返回值穿透到最外层

## async await:使用同步的港式去写异步代码

### 生成器 VS 协程
生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。

生成器函数的使用方式：
1. 在生成器函数内部执行一段代码，如果遇到yield关键字，那么JavaScript引擎将返回关键字后面的内容给外部，并暂停该函数的执行

2. 外部函数可以通过next方法恢复函数的执行。

协程的概念：
协程是一种比线程更加轻量级的存在，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。如果从A协程启动B协程，我们就把A协程称为B协程的父协程

协程不是被操作系统内核所管理，而完全是由程序所控制。

### async/await
async是一个通过异步执行并隐式返回Promise作为结果的函数

await 也是返回一个promise