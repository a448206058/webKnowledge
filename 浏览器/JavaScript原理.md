## 块级作用域

### 作用域（scope）
作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

在ES6之前，作用域只有俩种：全局作用域和函数作用域
* 全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期
* 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

* let、const 声明快级作用域：作用块内声明的变量不影响块外面的变量

块级作用域是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这俩者的结合，JavaScript引擎也就同时支持了变量提升和块级作用域了

## 作用域和闭包
### 作用域链
在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer

当一段代码使用了一个变量时，JavaScript引擎首先会在“当前的执行上下文”中查找该变量，如果在当前的变量环境中没有查找到，那么JavaScript引擎会继续在outer所指向的执行上下文中查找。我们把这个查找的链条称为作用域链

### 词法作用域
词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系

### 闭包
在JavaScript中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。

使用闭包的原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。

## this
执行上下文中包含了变量环境、词法环境、外部环境和this

this是和执行上下文绑定的
执行上下文主要分为三种——全局执行上下文、函数执行上下文和eval执行上下文

### 全局执行上下文中的this
全局执行上下文中的this是指向window对象的，这也是this和作用域的唯一交点，作用域链的最底端包含了window对象，全局执行上下文中的this也是指向window对象

### 函数执行上下文中的this
默认情况下也是指向window

### 改变this的指向
1. 通过call、apply
2. 通过对象调用方法设置：使用对象来调用其内部的一个方法，该方法的this是指向对象本身的。
在全局环境中调用一个函数，函数内部的this指向的是全局变量window
3. 通过构造函数中设置 new

### 总结
1. 当函数作为对象的方法调用时，函数中的this就是该读喜庆
2. 当函数被正常调用时，在严格模式下，this值是undefined，非严格模式下this指向的是全局对象window;
3. 嵌套函数中的this不会继承外层函数的this值

## 栈空间和堆空间
在使用之前就需要确认其变量数据类型的称为静态语言，把在运行过程中需要检查数据类型的语言称为动态语言。

支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。

### JavaScript的数据类型
JavaScript是一种弱类型的、动态的语言

JavaScript的数据类型一共有8种：Boolean、Null、Undefined、number、string、BigInt、symbol、Object

### 内存空间
代码空间、栈空间、堆空间

原生类型的数据值都是直接保存在栈中的，引用类型的值是存放在堆中的。

原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。

### 闭包
产生闭包的核心有俩步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。

## 垃圾回收
### 调用栈中的数据是如何回收的
JavaScript采用自动垃圾回收的策略，产生的垃圾数据都是由垃圾回收器来释放的

记录当前执行状态的指针（称为ESP）

JavaScript引擎会通过向下移动ESP来销毁该函数保存在栈中的执行上下文

### 堆中的数据是如何回收的
要回收堆中的垃圾数据，就需要用到JavaScript中的垃圾回收器了。

### 代际假说和分代收集
代际假说有俩个特点：
* 第一个是大部分对象在内存中存在的时间很短；
* 第二个是不死的对象，会活的更久。

在V8中会把堆分为新生代和老生代俩个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象

* 副垃圾回收器，主要负责新生代的垃圾回收
* 主垃圾回收器，主要负责老生代的垃圾回收

### 垃圾回收器的工作流程
1. 标记空间中活动对象和非活动对象
2. 回收非活动对象所占据的内存
3. 内存整理（可选）

### 副垃圾回收器
新生代中用Scavenge算法来处理。就是把新生代空间对半划分为俩个区域，一半是对象区域，一半是空闲区域

新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

垃圾清理阶段，会把存活的对象复制到空闲区域中，同时把这些对象有序地排列起来，所以这个复制过程，也就相当于完成来内存整理操作。

完成复制后，对象区域与空闲区域进行角色翻转，这样就完成来垃圾对象的回收操作。经过俩次垃圾回收依然还存活的对象，会被移动到老生区。这就是对象晋升策略

### 主垃圾回收器
采用标记-清除的算法进行垃圾回收的

### 全停顿
JavaScript是运行在主线程之上的，一旦执行垃圾回收算法，需要将正在执行的JavaScript脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿。

## V8是如何执行一段JavaScript代码的
### 编译器和解释器
编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留及其能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译来。

而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。

编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。

在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树来生成字节码，最后根据字节码来执行程序、输出结果

### V8是如何执行一段JavaScript代码的
1. 生成抽象语法树（AST)和执行上下文
Babel的工作原理就是先将ES6源码转换为AST，然后再将es6语法的AST转换为ES5语法的AST，最后利用ES5的AST生成JavaScript源代码。
ESLint检测流程也是需要将源码转换为AST，然后再利用AST来检查代码规范化的问题。

生成AST需要经过俩个阶段：
第一阶段是分词（tokenize)，又成词法分析，其作用是将一行行的源码拆解成一个个token。所谓token，指的是语法上不可能再分的、最小的单个字符或字符串。

第二阶段是解析（parse)，又称语法分析，其作用是将上一步生成的token数据，根据语法规则转化为AST。

2. 生成字节码
解释器Ignition，根据AST生成字节码
字节码就是介于AST和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。

3. 执行代码
解释器Ignition逐条解释执行
JIT编译器TurboFan一次编译热区代码

### JavaScript性能优化
1. 提升单词脚本的执行速度，避免JavaScript的长任务霸占主线程，这样可以使得页面快速响应交互；

2. 避免大的内联脚本，因为在解析HTML的过程中，解析和编译也会占用主线程；

3. 减少JavaScript文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。


## 消息队列和事件循环
消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。

通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果DOM有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。

等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为DOM变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。

## JavaScript面向对象
封装、继承以及多态
1. 封装：是一种通过接口抽象将具体实现包装并隐藏起来的方法
* 限制对对象内部组件直接访问的机制；
* 将数据和方法绑定起来，对外提供方法，从而改变对象状态的机制。

纯函数：函数不允许引用任何自由变量
函数的调用不允许改变其所属的上下文；
相同入参的函数调用一定能得到相同的返回值。

2. 继承：一个对象或者类能够自动保持另一个对象或者类的实现的一种机制。

3. 多态：指的是同样的接口，有着不同的实现。

## setTimeout是如何实现的？
浏览器页面是由消息队列和事件循环系统来驱动的

setTimeout是一个定时器，用来指定某个函数在多少毫秒之后执行

### 浏览器怎么实现setTimeout
* 首先，为了支持定时器的实现，浏览器增加了延时队列。
* 其次，由于消息队列排队和一些系统级别的限制，通过setTimeout设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。
* 最后，定时器使用过程中，还存在一些陷阱。

## XMLHttpRequest是怎么实现的？
是由浏览器的其他进程或者线程去执行，然后再将执行结果利用IPC的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中。

### 回调函数VS系统调用栈
将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。

回调函数是在主函数返回之前执行的，我们把这个回调过程称为同步回调。

回调函数在主函数外部执行的过程称为异步回调

## 交互设计和页面布局

### 单页面应用
用户打开一个页面，大部分操作都是在单个页面里面完成。SPA省去了页面跳转的突兀感受和等待时间，用户体验更加桌面化，操作迅速、切换无缝；

### 渐进式增强
渐进式增强，即Progressive Enhancement,强调的是可访问性，即允许不同能力的设备都能够访问网页的基本内容，使用网页的基本功能；但是，当用户使用更加现金的设备时，它能够给用户带来更强大的功能和更好的体验。

### 优雅降级

### 响应式布局
自适应性网页设计
