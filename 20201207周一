// 1． 第一个记忆周期：5分钟
// 2． 第二个记忆周期：30分钟 20201207 19:30
// 3． 第三个记忆周期：12小时 20201208 07:00
// 4． 第四个记忆周期：1天 20201208 19:00
// 5． 第五个记忆周期：2天 20201209 19:00
// 6． 第六个记忆周期：4天 20201211 19:00
// 7． 第七个记忆周期：7天 20201214 19:00
// 8． 第八个记忆周期：15天 20201223

//手写防抖函数
//防抖函数的原理：事件触发n秒内，如果再次触发，则重新计算
// 20201207 周一 --3-- 20201208 09:37 --4-- 20201208 18:42 --5-- 20201209 19:05 --6-- 20201211 18:51
function debounce(func, wait, immediate){
    var timeout, result;

    var debounced = function() {
        var context = this;
        var args = arguments;
        if(!timeout) clearTimeout(timeout);

        if(immediate){
            var callNow = !timeout;
            timeout = setTimeout(function(){
                timeout = null;
            },wait);
            if(!callNow) result = func.apply(context, args);
        }
        return result;
    }

    debounced.oncancel = function() {
        clearTimeout(timeout)
        timeout = null;
    }

    return debounced;
}


//手写节流函数
// 节流函数的原理，如果你持续触发事件，每隔一段时间，只触发一次
// 20201207 周一  --3-- 20201208 09:37  --4-- 20201208 18:46  --5-- 20201209 19:08 --6-- 20201211 18:57
// 方案一：通过时间戳来解决
function throttle(fn, wait){
    var pre = new Date();
    return function(){
        var context = this;
        var args = arguments;
        var now = new Date();
        if(pre - now >= wait){
            fn.apply(context, args);
            pre = null;
        }
    }
}
//方案二：通过定时器解决
function throttle(fn, wait){
    var timer = null;
    return function(){
        var context = this;
        var args = arguments;
        if(!timer){
            timer = setTimeout(function(){
                fn.apply(context, args);
                timer = null;
            },wait);
        }
    }
}

//实现一个new操作符  --3-- 20201208 09:37 --4-- 20201208 18:49 --5-- 20201209 19:14 --6-- 20201211 19:07
// 1.用new Object()的方式新建了一个对象obj
// 2.取出第一个参数，就是我们要传入的构造函数。此外因为shift会修改原数组，所以arguments会被去除第一个参数
// 3.将obj的原型指向构造函数，这样obj就可以访问到构造函数原型中的属性
// 4.使用apply，改变构造函数this的指向到新建的对象，这样obj就可以访问到构造函数中的属性
// 5.返回obj


//1.创建一个新对象
//2.将obj的原型指向构造函数
//3.改变this的指向为新建的对象

function objectFactory() {
    var obj = new Object(), Constructor = [].shift.call(arguments);
    obj.__proto__ = Constructor.prototype;
    var ret = Constructor.apply(obj, arguments);
    return typeof ret === 'object' ? ret : obj;
}

/*
    typescript与javascript的区别  --2-- 20201207 19:30 --3-- 20201208 08:40 --4-- 20201208 18:49  --5-- 20201209 19:14 --6-- 20201211 19:07
        typescript是javascript的超集，扩展了javascript的语法，因此现有的javascript代码可与typescript一起工作无需任何修改,typescript通过类型注解提供编译时的静态类型检查。
        typescript可处理已有的javascript代码，并只对其中的typescript代码进行编译
        typescript增加的功能有：
            类型批注和编译时类型检查
            类型推断
            类型擦除
            接口
            枚举
            mixin
            泛型编程
            名字空间
            元组
            Await
            类
            模块
            lambda函数的箭头语法
            可选参数以及默认参数

   typescript基础语法
       typescript程序由以下几个部分组成
       模块
       函数
       变量
       语句和表达式
       注释

       空白和换行
       typescript会忽略程序中出现的空格、制表符和换行符。
       空格、制表符通常用来缩进代码，使代码易于阅读和理解。

       typescript区分大小写
       typescript区分大写和小写字符。

       分号是可选的
       同一行一定用分号

       typescript注释
       单行注释 //
       多行注释 / ** /

       typescript与面向对象
       面向对象是一种对现实世界理解和抽象的方法。
       typescript是一种面向对象的编程语言。
       面向对象主要有俩个概念：对象和类。
       对象：对象是类的一个实例，有状态和行为。
       类：类是一个模板，它描述一类对象的行为和状态。
       方法：方法是类的操作的实现步骤。

       class Site {
           name(): void {
               console.log("Runoob")
           }
       }
       var obj = new Site();
       obj.name();

    typescript基础类型    --2-- 20201207 20:00  --3-- 20201208 08:54 --5-- 20201209 19:17 --6-- 20201211 19:20
        any 任意类型 声明为any的变量可以赋予任意类型的值
            let value: any
            常用于三种情况：
            1.变量的值会动态改变时，比如来自用户的输入，任意值类型可以让这些变量跳过编译阶段的类型检查
            2.改写现有代码时，任意值允许在编译时刻选择地包含或移除类型检查
            3.定义存储各种类型数据的数组时
        number 数字类型 双精度64位浮点值。它可以用来表示整数和分数。
            let value: number
        string 字符串类型
            let value: string
        boolean 布尔类型
            let flag: boolean = true;
        [] 数组类型
            let arr: number[] = [1, 2];
            let arr: Array<number> = [1, 2];
        [] 元组类型 用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。
            let x: [string, number];
            x = ['Runoob', 1]; // 运行正常
        enum 枚举 枚举类型用于定义数值集合。
            enum Color {Red, Green, Blue};
            let c: Color = Color.Blue;
            console.log(c); // 输出 2
        void void 用于标识方法返回值的类型，表示该方法没有返回值。
            function hello(): void {
                alert("Hello Runoob");
            }
        null null 表示对象值缺失
            null是一个只有一个值的特殊类型。表示一个空对象引用。
            用typeof检测null返回是object。
        undefined undefined 用于初始化变量为一个未定义的值
            在javascript中,undefined是一个没有设置值的变量。
            typeof一个没有值的变量会返回undefined。
            null和undefined是其他任何类型的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成null或undefined。
            而在typescript中启用严格的空校验特性，就可以使得null和undefined只能被赋值给void或本身对应的类型
        never never never是其他类型（包括null和undefined）的子类型，代表从不会出现的值。
        注意：Typescript和JavaScript没有整数类型。

    typescript变量声明  --1-- 20201207 20:00 --2-- 20:23 --3-- 20201208 08:57 --5-- 20201209 19:18  --6-- 20201211 19:23
        变量是一种使用方便的占位符，用于引用计算机内存地址
        我们可以把变量看做存储数据的容器。
        typescript变量的命名规则：
        变量名称可以包含数字和字母。
        除了下划线_和美元$符号外，不能包含其他特殊字符，包括空格。
        变量名不能以数字开头

        变量使用前必须先声明，我们可以使用var来声明变量。
        我们可以使用以下四种方式来声明变量：
        声明变量的类型及初始值：
        var [变量名] : [类型] = 值;
        声明变量的类型，但没用初始值，变量值会设置为undefined
        var [变量名] : [类型];
        声明变量并初始值，但不设置类型，该变量可以是任意类型：
        var [变量名] = 值;
        声明变量没有设置类型和初始值，类型可以是任意类型，默认初始值为undefined

        类型断言
        类型断言可以用来手动指定一个值的类型，即允许变量从一种类型更改到另一种类型
        var str2:number = <number> <any> str // string 类型
        类型断言不被称为类型转换，是因为类型断言纯粹是一个编译时语法，同时，它也是一种为编译器提供关于如何分析代码的方法。

        类型推断
        当类型没有给出时，typescript编译器利用类型推断来推断类型
        如果由于缺乏声明而不能推断出类型，那么它的类型被视作默认的动态any类型。
        var num = 2; // 类型推断为 number
        console.log("num变量的值为" + num);
        num = "12"; // 编译错误

        变量作用域
        变量作用域指定了变量定义的位置
        程序中变量的可用性由变量作用域决定。
        typescript有以下几种作用域：
            全局作用域
            类作用域 也可称为字段。类变量声明在一个类里头
            局部作用域

    typescript运算符  --1-- 20201207 20:08 --2-- 20:30  --3-- 20201208 08:58 --5-- 20201209 19:19 --6-- 20201211 19:24
        运算符用于执行程序代码运算，会针对一个以上操作数项目来进行运算。
        包含以下几种运算：
            算术运算符
            逻辑运算符
            关系运算符
            按位运算符
            赋值运算符
            三元/条件运算符
            字符串运算符
            类型运算符
                typeof instanceof
            其他运算符
                -负号  +连接字符串

    typescript条件语句  --1-- 20201207 20:12 --3-- 20201208 08:59 --5-- 20201209 19:19 --6-- 20201211 19:24
        条件语句用于基于不同的条件来执行不同的动作。
        typescript条件语句是通过一条或多条语句的执行结果类决定执行的代码块。
        if else switch case

    typescript循环 --1-- 20201207 20:22 --3-- 20201208 08:59
        for(){}
        for in
            for(j in n){
            }
        for of、forEach、every和some
        es6中引入for of 循环替代for in和forEach()，并支持新的迭代协议。
        for of 允许你遍历Arrays（数组）,Strings（字符串）,Maps（映射）,Sets（集合）等
        while循环
        do while 先执行一次 再判断 为true继续执行
        break
            1.出现在一个循环内时，循环会立即终止
            2.它可用于终止switch语句中的一个case
        continue语句
            1.跳过当前循环强迫开始下一次循环。
            2.对于for循环，continue语句执行后自增语句仍然会执行。对于while和do...while循环，重新执行条件判断语句
        无限循环
            for(;;){} while(true)

    typescript函数
        函数是一组一起执行一个任务的语句。
        根据每个函数执行一个特定的任务来进行的。
        函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。
        可选参数
        默认参数

    typescript number —1— 20201207 09:54 —2— 10:30   --3-- 20201208 09:00 --5-- 20201209 19:20 --6-- 20201211 19:26
    number对象是原始数值的包装对象。
    对象属性
        MAX_VALUE MIN_VALUE NaN NEGATIVE_INFINITY 负无穷大
        POSITIVE_INFINITY 正无穷大
        prototype 静态属性。
        constructor 返回对创建此对象的Number函数的引用
    对象方法
	    toExponential() 把对象的值转换为指数计数法
	    toFixed()
	    toLocalString() 把数字转换为字符串
	    toPrecision() 把数字格式化为指定的长度
	    toString()
	    valueOf()

    Typescript string 20201207 10:09 —1— —2— 10:30   --3-- 20201209 09:01 --5-- 20201209 19:21 --6-- 20201211 19:26
    string 对象用于处理文本
        对象属性
            constructor 对创建该对象的函数的引用
            length 返回字符串的长度
            prototype 允许您向对象添加属性和方法
        string 方法
	        charAt() 返回在指定位置的字符。
	        charCodeAt() 返回在指定的位置的字符的Unicode编码
	        concat()
	        indexOf()
	        lastIndexOf()
	        localeCompare()
	        match()
	        replace()
	        search()
	        slice()
	        split()
	        substr() 从起始索引号提取字符串中指定数目的字符
	        substring() 提取字符串中俩个指定的索引号之间的字符。
	        toLocaleLowerCase()
	        toLocaleUpperCase()
	        toLowerCase()  把字符串转换为小写
	        toString() 返回字符串
	        toUpperCase() 把字符串转换为大写
	        valueOf() 返回指定字符串对象的原始值

    typescript array —1—20201207 10:30 —2— 11:00  --3-- 20201208 08:59 --5-- 20201209 19:22 --6-- 20201211 19:28
        数组对象是使用单独的变量名来存储一系列的值
        var sites: string[];
        var nums: number[]
        如果数组声明时未设置类型，则会被认为是any类型，在初始化时根据第一个元素的类型来推断数组的类型。
        Array对象 我们也可以使用Array对象创建数组
        Array对象的构造函数接受以下俩种值： 表示数组大小的数组 初始化的数组列表，元素使用逗号分隔值
        数组解构
            var arr:number[] = [12, 13]
            var [x, y] = arr
        数组迭代
            用for 多维数组 一个数组的元素可以是另一个数组，这样就构成了多维数组 var multi: number[][] = [[1, 2, 3], [23, 24, 25]]
        数组在函数中的使用
            作为参数传递给函数
            作为函数的返回值
        数组方法
            concat() 连接俩个或更多的数组
            every() 循环每个元素
            filter()
            forEach()
            indexOf()
            join()
            lastIndexOf()
            map()
            pop() 删除数组中最后一个元素并返回删除的元素
            push() 向数组的末尾添加一个或更多元素，并返回新的长度
            reduce() 将数组元素计算为一个值
            reduceRight() 将数组元素计算为一个值（从右到左）
            reverse() 反转数组的元素顺序
            shift() 删除并返回数组的第一个元素
            slice() 选取数组的一部分，并返回一个新数组。
            some() 检测数组元素中是否有元素符合指定条件。
            sort() 对数组的元素进行排序。
            splice() 从数组中添加或删除元素
            toString() 把数组转换为字符串，并返回结果。
            unshift() 向数组的开头添加一个或更多元素，并返回新的长度。

    typescript map对象 —1— 20201207 10:47 —2— 11:18  --3-- 20201208 09:06  --5-- 20201209 19:23 --6-- 20201211 19:29
        Map 对象保存键值对，并且能够记住键的原始插入顺序。
        任何值（对象或者原始值）都可以作为一个键或一个值
        Map是ES6中引入的一种新的数据结构
        typescript使用map类型和new 关键词来创建map
        Let map = new Map()
        map相关的函数与属性：
        Map.clear() - 移除map对象的所有键/值对。
        Map.set() - 设置键值对，返回该map对象
        Map.get() - 返回键对应的值，如果不存在，则返回undefined
        Map.has() - 返回一个布尔值，用于判断map中是否包含键对应的值
        Map.delete() - 删除map中的元素，删除成功返回true,失败返回false
        map.size - 返回map对象键/值对的数量
        Map.keys() - 返回一个iterator对象，包含了map对象中每个元素的键
        Map.values() - 返回一个新的iterator对象，包含了map对象中每个元素的值
        迭代map map对象中元素是按顺序插入的，我们可以迭代map对象，每一次迭代返回[key, value]数组
        typescript使用for of来实现迭代

    Typescript 元组. 20201207 10:54 —1— —2— 11:20  --3-- 20201208 08:59 --5-- 20201209 19:23 --6-- 20201211 19:30
        我们知道数组中元素的数据类型一般都是相同的（any[]类型的数组可以不同），如果存储的元素数据类型不同，则需要使用元组
        元组中允许存储不同类型的元素，元组可以作为参数传递给函数
        var tuple_name = [value1, value2, value3, …value n]
        var my tuple = [10, “runoff”]
        元组运算
            push() pop()
        更新元组
            元组是可变的，这意味着我们可以对元组进行更新操作。
        解构元组 v
            ar a = [10, “Runoob”] var [b, c] = a

    typescript联合类型. —1— 20201207 11:18. —2— 11:41  --3-- 20201208 09:10 --5-- 20201209 19:24 --6-- 20201211 19:30
        联合类型（union types）可以通过管道将变量设置多种类型，赋值时可以根据设置的类型来赋值。
        注意：只能赋值指定的类型，如果赋值其它类型就会报错
            type1|type2|type3 var val:string|number val = 12
            console.log(“数字为” + val)
        也可以将联合类型作为函数参数使用
            function disp(name: string | string[]){ }
        联合类型数组 我们也可以将数组声明为联合类型： var arr:number[] | string[]

    Typescript接口. —1— 20201207 11:41  --3-- 20201208 09:12 --5-- 20201209 19:24 --6-- 20201211 19:30
        接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。
            interface interface_name {
            }
        需要注意接口不能转换为javascript。它只是typesript的一部分
            interface Iperson {
	            firstName: string,
	            lastName: string,
	            sayHi: ()=> string
            }
            var customer:IPerson = {
            }
        联合类型和接口.
        接口和数组
	        接口中我们可以将数组的索引值和元素设置为不同类型，索引值可以是数字或字符串。
	        interface nameList {
		        [index: number]: string
	        }
        接口继承
	        接口继承就是说接口可以通过其他接口来扩展自己
	        typescript允许接口继承多个接口
	        继承使用关键词extends
	        单接口继承语法格式：
		        Child_interface_name extends super_interface_name
	        多接口继承语法格式：
		        Child_interface_name extends super_interface1_name, super_interface2_name,super_interfaceN_name
            单继承实例
	            interface Person {
		            age: number
	            }
	            interface Musician extends Person {
		            instrument:v string
	            }
	            var drummer = <Musician>{};
            多继承实例
	            interface IParent1 {
		            v1:	number
	            }
	            interface IParent2 {
		            v2: number
	            }
	            interface	Child extends IParent1, IParent2 {}

    typescript类  --3-- 20201208 09:15 --5-- 20201209 19:25
        typescript是面向对象的javascript 类描述了所创建的对象共同的属性和方法。
        typescript支持面向对象的所有特性，比如类、接口等。
        typescript类定义方式如下：
            class class_name { //类作用域 } 定义类的关键词为class，后面紧跟类名，类可以包含以下几个模块
                字段-字段是类里面声明的变量。
                字段表示对象的有关数据。
                构造函数-类实例化时调用，可以为类的对象分配内存。
                方法-方法为对象要执行的操作。
                创建类的数据成员 this关键字表示当前类实例化的对象。
                注意构造函数的参数名与字段名相同
                    class Car {
                        // 字段
                        engine: string;
		                // 构造函数
		                constructor(engine: string) {
			                this.engine = engine
		                }
		                disp(): void {
		                }
	                }
        创建实例化对象
	        我们使用new关键字来实例化类的对象
	        var object_name = new class_name([arguments])
	    类实例化时会调用构造函数
	        var obj = new Car(“Engine 1”)
	    类中的字段属性和方法可以使用.号来访问
	        //访问属性
	        obj.field_name
	        //访问方法
	        obj.function_name()
        类的继承
	        typescript支持继承类，即我们可以在创建类额时候继承一个已存在的类，这个已存在的类称为父类，继承它的类称为子类
	        类继承使用关键字extends，子类除了不能继承父类的私有成员（方法和属性）和构造函数，其它的都可以继承
	        子类只能继承一个父类，typescript不支持继承多个类，但支持多重继承

	    继承类的方法重写
	        类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。
	        其中super关键字是对父类的直接饮用，该关键字可以引用父类的属性和方法

	    static关键字
	        static关键字用于定义类的数据成员为静态的，静态成员可以直接通过类名调用。

	    instanceof 运算符
	        instanceof运算符用于判断对象是否是指定的类型，如果是返回true,否则返回false

	    访问控制修饰符
	        typescript中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。typescript支持3种不同的访问权限。
	        public（默认）：公有，可以在任何地方被访问。
	        protected：受保护，可以被其自身以及其子类和父类访问。
	        private：私有，只能被其定义所在的类访问。

	    类和接口
	        类可以实现接口，使用关键字implements，并将interest字段作为类的属性使用
*/
