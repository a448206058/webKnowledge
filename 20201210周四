// 1． 第一个记忆周期：5分钟
// 2． 第二个记忆周期：30分钟 20201210 19:30
// 3． 第三个记忆周期：12小时 20201211 07:00
// 4． 第四个记忆周期：1天 20201211 19:00
// 5． 第五个记忆周期：2天 20201212 19:00
// 6． 第六个记忆周期：4天 20201214 19:00
// 7． 第七个记忆周期：7天 20201217 19:00
// 8． 第八个记忆周期：15天 20201223

/*继承
    继承的几种方式 --1-- 20201210 11:50 --2-- 20201210 13:10 --3-- 20201211 09:07 --4-- 20201211 19:58
    6种 原型链继承、借用构造函数继承、原型链+借用构造函数的组合继承 组合继承1 组合继承2 es6class的继承 extends
    原型链继承
        子类型的原型为父类型的一个实例对象
        将子类的原型指向了父类的实例，所以子类的实例就可以通过__proto__访问到student.prototype也就是父类的实例，这样就可以访问到
        父类的私有方法,然后再通过__proto__指向父类的prototype就可以获得父类原型上的方法。
        子类继承父类的属性和方法是将父类的私有属性和公有方法都作为自己的公有属性和方法。

        特点：父类新增原型方法/原型属性，子类都能访问到
        简单，易于实现

        缺点：无法实现多继承
        来自原型对象的所有属性被实例共享
        创建子类实例时，无法向父类构造函数传参
        function Person(){
        }
        function student(){
        }
        student.prototype = new Person();

    借用构造函数继承
        在子类型构造函数中通用call()调用父类型构造函数
        function Person() {
        }
        function student() {
            person.call(this, name, age);
        }
        特点：
            解决了原型链继承中子类实例共享父类引用属性的问题
            创建子类实例时，可以向父类传递参数
            可以实现多继承（call多个父类对象）
        缺点：
            实例并不是父类的实例，只是子类的实例
            只能继承父类的实例属性和方法，不能继承原型属性和方法
            无法实现函数复用，每个子类都要父类实例函数的副本，影响性能

    原型链+借用构造函数的组合继承
        通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用
        function person() {
        }
        function student(){
            person.call(this, name ,age);
        }
        student.prototype = new Person();
        student.prototype.constructor = student;
        优点：
            可以继承实例属性/方法，也可以继承原型属性/方法
            不存在引用属性共享问题
            可传参
            函数可复用
        缺点：
            调用了俩次父类构造函数，生成了俩分实例

     组合继承优化1
        这种方式通过父类原型和子类原型指向同一对象，子类可以继承到父类的公有方法当做自己的公有方法，
        而且不会初始化俩次实例方法/属性，避免组合继承的缺点

        function person(){
        }
        function student(){
            person.call(this,name,age);
        }
        student.prototype = person.prototype;
        优点：
            不会初始化俩次实例方法/属性，避免组合继承的缺点
        缺点：
            没办法辨别实例是子类还是父类创造的，子类和父类的构造函数指向是同一个

    组合继承优化而
        借助原型可以基于已有的对象来创建对象，var b = Object.create(A)已A对象为原型，生成了B对象。B继承了的所有属性和方法
        function person(){
        }
        function student(){
            person.call(this, name, age)
        }
        student.prototype = Object.create(person.prototype)
        student.prototype.constructor = student;

    ES6 class的继承 extends
 */


/*
    vue
        组件中的data为什么是一个函数？ 20201210 14:50 --1-- 15:00  --2-- 15:26  --3-- 20201211 09:12 --4-- 20201211 20:00
            一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数
            如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同实例之间data不冲突，data必须是一个函数。

        子组件为什么不可以修改父组件传递的Prop?怎么理解单向数据流 20201210 14:59 --1-- 15:04 --2-- 15:28  --3-- 20201211 09:14 --4-- 20201211 20:02
            vue提倡单向数据流，即父级props的更新会流向子组件，但是反过来则不行
            这是为了防止意外的改变父组件状态，使得应用的数据变得难以理解
            如果破坏了单向数据流，当应用复杂时，debug的成本会非常高

        v-model是如何实现双向绑定的？ 20201210 15：24 --1-- 15:31  --2-- 16:00  --3---- 20201211 09:18 --4-- 20201211 20:05
            v-model是用来在表单控件或组件上创建双向绑定的
            他的本质是v-bind和v-on的语法糖
            在一个组件上使用v-model，默认会为组件绑定名为value的prop和名为input的事件

        nextTick的实现原理是什么 20201210 16：00 --1-- 16:07 --2-- 16:33  --3---- 20201211 09:21 --4-- 20201211 20:06
            作用：将回调延迟到下次DOM更新周期之后执行
            下次DOM更新周期：其实是下次微任务执行时更新DOM。而nextTick是将回调添加到微任务中
            原理：
            1.先定义了一个callbacks存放所有的nextTick的回调函数
            2.然后promise mutationObserver setImmediate setTimeout来完成异步执行

       vue不能检测数组的哪些变动？vue怎么用vm.$set()解决对象新增属性不能响应的问题？ 20201210 16:09 --1-- 16:13  --2-- 16:35  --3---- 20201211 09:21 --4-- 20201211 20:08
            利用索引值直接设置一个数组项时
            修改数组的长度时
            修改办法 $set(value ,index, new)
            Array.prototype.splice

            vue.$set实现原理是：
                如果目标是数组，直接使用数组的splice方法触发响应式。
                如果目标是对象，会先判断属性是否存在，对象是否是响应式
                如果最终要对属性进行响应式处理，则是通过调用defineReactive方法进行响应式处理

       vue事件绑定的原理是什么？ 20201210 16:14 --1-- 16:22 --2-- 16:44  --3---- 20201211 09:07 --4-- 20201211 20:09
            原生事件的绑定主要是通过addEventLister来实现的，组件事件绑定主要是通过v-on来实现的

       说一下虚拟DOM以及KEY属性的作用？ 20201210 16:32 --1-- 16:36 --2-- 16:58  --3---- 20201211 09:25 --4-- 20201211 20:09
            由于在浏览器中操作DOM是很昂贵的。频繁的操作DOM，会产生一定的性能问题。这就是虚拟DOM的产生原因。
            virtual dom本质就是用一个原生的JS对象去描述一个DOM节点。是对真实DOM的一层抽象。（也就是源码中的VNode类）
            虚拟DOM的实现原理主要包括了一下3部分：
            用javascript对象模拟真实DOM树，对真实DOM进行抽象；
            diff算法 一 比较俩颗虚拟DOM树的差异
            patch算法 —— 将俩个虚拟DOM独享的差异应用到真实的DOM树

            Key是为vue中vnode的唯一标记，通过这个key，我们的diff操作可以：
            更准确：因为带key就不是就地复用了，在sameNode函数a.key === b.key对比中就可以避免就地复用的情况。所以会更加准确
            更快速：利用key的唯一性生成map对象来获取对应节点，比遍历方式更快

     说一下你对vue的生命周期的理解？ 20201210 17:04  --1-- 17:10 --2-- 17:29  --3-- 20201211 09:37 --4-- 20201211 20:13
           beforeCreate 实例初始化之后，数据观察和事件配置完成之前被调用
           created 实例创建完成之后，数据观测和事件配置完成了，可以做一些初始数据的获取，无法与dom进行交互
           beforeMount 发生挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟DOM已经创建完成，即将开始渲染。可以进行数据的修改不会触发update.
           Mounted 真实的DOM挂载完毕，数据完成双向绑定，可以访问到DOM节点，使用$refs属性对DOM进行操作
           beforeUpdate 发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染
           updated 发生在更新完成之后，当前阶段组件DOM已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。
           activated  keep-alive缓存组件激活时
           deActiveted keep-alive缓存组件停用时
           beforeDestory 发生在实例销毁之前，在当前阶段实例完全可以被使用，可以在这时进行善后收尾工作。
           destoryed 实例销毁

     vue组件生命周期调用顺序是什么样的？ 20201210 17:07 --1-- 17:14 --2-- 18:15  --3-- 20201211 09:51 --4-- 20201211 20:16
           组件调用的顺序都是先父后子，渲染完成是先子后父
           组件销毁操作是先父后子，销毁完成是先子后父

     在什么阶段才能访问操作DOM？ 20201210 17:15 --1-- 17:28 --2-- 18:15 --4-- 20201211 20:16
        mounted

     你的接口请求一般放在哪个生命周期中？ 20201210 17:17 --1-- 17:28 --2-- 18:16   --3-- 20201211 09:52 --4-- 20201211 20:16
        created 、beforeMount beforeMounted
        放到created中 能更快获取数据 减少loading时间

     vue理由hash模式和history模式实现原理分别是什么？他们的区别是什么？ 20201210 23:33 --1-- 23:38  --2-- 11:53   --3-- 20201211 09:52 --4-- 20201211 20:17
        hash模式：
            #后面hash值的变化，不会导致浏览器向服务器发出请求，就不会刷新页面；
            通过监听hashchange事件可以知道hash发生了哪些变化，然后根据hash变化来实现更新页面部分内容的操作。
        history模式：
            history模式的实现，主要是HTML5标准发布的俩个API，pushState和replaceState，这俩个API可以在改变url，
            但是不会发送请求。这样就可以监听Url变化来实现更新页面部分内容的操作。
        区别：
            url展示上，hash模式有"#"，history模式没有：
            刷新页面时，hash模式可以正常加载到hash值对应的页面，而history没有处理的话，会返回404，一般需要后端将所有
            页面都配置重定向到首页路由
            兼容性，hash可以支持低版本浏览器和IE

    路由懒加载是什么意思？如何实现路由懒加载？20201210 23:41 --1-- 23:47  --2-- 20201211 00:10    --3-- 20201211 10:02 --4-- 20201211 20:17
        路由懒加载：就是访问的时候才加载对应的组件
        vue异步组件 resolve require resolve
        import
        webpack require ensure

    vue-router导航守卫有哪些？20201210 23:49 --1-- 23:56  --2-- 00:18    --3-- 20201211 10:04 --4-- 20201211 20:18
        全局前置/钩子：beforeEach、beforeResolve、afterEach
        路由独享的守卫：beforeEnter
        组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave

    说说vue和react的异同  20201211 00:12 --1-- 00:19  --2-- 00:35    --3-- 20201211 10:04 --4-- 20201211 20:19
        同：
        使用virtual dom
        提供了响应式reactive和组件化composable的视图组件
        异：
        在react应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树
        在vue应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染
        在react中，一切都是javacript

    什么是mixin?  20201211 00:28 --1--  00:32 --2--     --3-- 20201211 10:06 --4-- 20201211 20:21
        mixin使我们能够为vue组件编写可插拔和可重用的功能。
        如果你希望在多个组件之间重用一组组件选项，例如生命周期hook、方法等，则可以将其编写为mixin，并在组件中简单的
        引用它。
        然后将mixin的内容合并到组件中。如果你要在mixin中定义生命周期hook，那么它在执行时将优化于组件自己的hook.

   在vue实例中编写生命周期hook或其他option/properties时，为什么不使用箭头函数？ 20201211 00:33 --1-- 38    --3-- 20201211 10:07 --4-- 20201211 20:24
       箭头函数自己没有定义this上下文。
       当你在vue程序中使用箭头函数时，this关键字不会绑定到vue实例，因此会引发错误，所以强烈建议该用标准函数声明

   vue模版编译原理知道吗，简单说一下？20201211 00:53 --2-- 20201211 16:13 --4-- 20201211 20:24
       简单说，vue的编译过程就是将template转化为render函数的过程。会经历以下阶段（生成AST树/优化/codegen)
       首先解析模版，生成AST语法树（一种用javascript对象的形式来描述整个模版）
       使用大量的正则表达式对模版进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。
       vue的数据是响应式的，但其实模版中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的
       DOM也不会变化。
       那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点（静态节点）我们就可以跳过对它们的对比，
       对运行时的模版起到很大的优化作用。
 */

/*
   算法
       链表 20201210 10:00
       链表相对于数组来说，要复杂的多，首先链表不需要连续的内存空间，它时由一组零散的内存块透过指针连接而成，所以，每一个块中必须包含当前节点内容以及
       后续指针。最常见的链表类型有单链表双链表以及循环链表。

       确定解题的数据结构：单链表、双链表或循环链表等
       确定解题思路：如何解决问题
       画图实现：画图可以帮助我们发现思维中的漏洞
       确定边界条件：思考解题中是否有边界问题以及如何解决
       代码实现

       单链表结构：
       function List() {
           let Node = function(element){
               this.element = element
               this.next = null
           }
           let head = null
           let length = 0
           this.getList = function() { return head}
           this.search = function(element) {
               let p = head;
               if(head){
                   while(p.next){
                       if(p.element === element){
                           break;
                       }
                   }
               }
           }
           this.append = function(element) {
               let node = new Node(element),
               p = head;
               if(!p){
                   return false;
               }esle{
                   while(p.next){
                       if(p.element === element) return true
                   }
               }
           }
           this.insert = function(position, element){}
           this.remove = function(element){}
           this.isEmpty = function() {}
           this.size = function() {}
       }

       1.追加节点
       //1.确定结构 单链表
       //2.确定解题思路 将最后一个节点中next指向为要加入的节点 加入的节点next指向为null
       //3.画图
       //4.确定边界条件 1.没有节点时 head 为 2.有节点
       //5.代码实现

       2.查找
       //1.确定结构 单链表
       //2.确定解题思路 遍历每个节点 看data是否相同
       //3.画图
       //4.确定边界条件 是否为空 next是否为null
*/


