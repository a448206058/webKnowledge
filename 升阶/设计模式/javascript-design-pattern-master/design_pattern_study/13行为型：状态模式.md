#### 状态模式

和策略模式相似——长得像、解决的问题可以说没啥本质上的差别。

##### ~一杯咖啡带来的思考

咖啡机在不同的选择下有不同的任务（制作工序）

##### ~一台咖啡机的诞生

不同的“选择”间的切换，本质就是状态的切换。这个能做四种咖啡的咖啡机体内，蕴含着四种状态：

```
- 美式咖啡态（american）：只吐黑咖啡
- 普通拿铁态（latte）：黑咖啡加奶
- 香草拿铁态（vanillaLatte）：黑咖啡加奶加香草糖浆
- 摩卡咖啡态（mocha）：黑咖啡加奶加巧克力
```

可以使用简单粗暴的if-else

#####~改造咖啡机的状态切换机制

根据“单一职责”和“开放封闭”原则，改造咖啡机：

**!职责分离**

咖啡制作过程不可复用。

changeState函数，只管做好自己的事（切换状态），做咖啡的过程也写在里面，不合理。

**!开放封闭**

加入要增加“气泡美式”这个咖啡品种，就不得不去修改changeState的函数逻辑，违反了开放封闭的原则。

要像策略模式一样，想办法把咖啡机状态和咖啡制作工序之间的映射关系（也就是分发过程）用一个更优雅的方式做掉。=》对象映射

此时，我们已经实现了一个js版本的状态模式。但暗含一个非常重要的隐患——stateToProcessor里的工序函数，感知不到咖啡机的内部状况。

**!策略与状态的辨析**

策略模式是对算法的封装。算法和状态对应的行为函数虽然本质上都是行为，但是算法的独立性高多了。

比如询价算法，只需要读取一个数字，就能返回结果，它和计算主体之间可以是分离的，只要关注计算逻辑本身就可以了。

状态不一样。比如制作咖啡，需要考虑咖啡机里的原材料数量，行为函数需要考虑够不够，能不能继续执行下去，等等。行为函数必须能拿到咖啡机这个主体的各种信息——必须得对主体有感知。

策略模式和状态模式相似，都封装行为、通过委托来实现行为分发。但**策略模式中的行为函数**是“潇洒”的行为函数，不依赖调用主题、互相平行、各自为政，而**状态模式中的行为函数**，首先是和状态主体之间存在着关联，由状态主体把它们串在一起；另一方面，因为关联着同样的一个/一类主体，所以不同状态对应的行为函数可能并不会很割裂。

**!进一步改造**

把咖啡机和它的状态处理函数建立关联。

有一种思路，是将每一个状态所对应的一些行为抽象成类，然后通过传递this的方式来关联状态和主体。——这种一般还需要实现抽象工厂，比较麻烦。

更方便也更常用的解决方案，把状态-行为映射对象作为主体类对应实例的一个属性添加进去。

如此，就可以在stateToProcessor轻松拿到咖啡机的实例对象，进而感知咖啡机这个主体。



##### ~状态模式复盘

状态模式定义：

> 状态模式（state pattern）：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。

状态模式解决的问题：

> 主要解决的是，当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。

和本节做的事唯一区别在于，定义里强调了“类”的概念。在实践中，一个对象的状态如果复杂到了不得不给它的每N种状态划分为一类、一口气划分很多类这种程度，需要反思一个这个对象是不是做太多事情了。事实上，在大多数场景里，行为划分都可以控制在“函数”这个粒度。