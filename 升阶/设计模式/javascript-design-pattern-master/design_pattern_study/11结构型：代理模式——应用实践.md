业务开发中最典型、最实用、最常见的四种代理类型：事件代理、虚拟代理、缓存代理和保护代理。



#### ~事件代理

场景：一个父元素下有多个子元素

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Proxy Demo —— 事件代理</title>
</head>
<body>
	<div id="father">
		<a href="#">链接1号</a>
		<a href="#">链接2号</a>
		<a href="#">链接3号</a>
		<a href="#">链接4号</a>
		<a href="#">链接5号</a>
		<a href="#">链接6号</a>
	</div>
</body>
</html>
```

需求：鼠标点击每个a标签，弹出内容提示。这意味着至少要安装6个监听函数给6个不同的元素（一般用循环实现），如果标签进一步增多，那么性能开销会加大。

**key**：事件本身具有”冒泡“的特性：当点击a元素时，点击事件会”冒泡“到父元素div上的，从而被监听到。

=》点击事件的监听函数只需要在div元素上被绑定一次即可，而不需要在子元素上被绑定N次——这种做法就是事件代理，可以很大程度上提高代码的性能。

**事件代理的实现**

点击操作不会直接触及目标子元素，而是由父元素对事件进行处理和分发、间接地将其作用于子元素。



#### ~虚拟代理

场景：预加载Pre-Load

复习：懒加载Lazy-Load

针对图片加载时机的优化：在一些图片量比较大的网站，如电商、团购、小游戏等，如果在用户打开页面就把所有图片资源加载完毕，很可能造成白屏、卡顿。

方案：采取”先占位、后加载“的方式来展示图片——在元素露出之前，给图片一个div作占位，当它滚动到可视区域时，再即时地去加载真实的图片资源，这样做既减轻了性能压力、又保住了用户体验。

**图片预加载**

主要为了避免网络不好、或图片太大时，页面长时间给用户留白的尴尬。

常见操作：先让这个img标签展示一个占位图，然后创建一个image实例，让这个image实例的src指向真实的目标图片地址、观察该image实例的加载情况——当对应的真实图片加载完毕后，即已经有了该图片的缓存内容，再将DOM上的img元素的src指向真实的目标图片地址。

这样直接去取目标图片的缓存，展示速度会非常快。

`ProxyImage`帮我们调度了预加载相关的工作，我们可以通过`ProxyImage`这个代理，实现对真实img节点的间接访问，并得到想要的效果。`virtualImage`这个对象，始终存在于JavaScript世界中、代替真实DOM发起了图片加载请求、完成了图片加载工作，却从未在渲染层出现。因此这种模式被称为”**虚拟代理**“模式。



####~缓存代理

场景：应用于一些计算量较大的场景里。

这种场景下，需要”用空间换时间“——当我们需要用到某个已经计算过的值的时候，不想再耗时进行二次计算，而是希望能从内存里去取出现成的计算结果。

这种场景下，就需要一个代理来帮我们在进行计算的同时，进行计算结果的缓存。

**典型的一个例子**，对传入的参数进行求和：

`proxy-cache.js`

proxyAddAll针对重复的入参只会计算一次，将大大节省计算过程中的时间开销。尤其有大量入参、做反复计算。



#### ~保护代理

场景：婚介所，保护用户的私人信息。

校验是否实名认证，校验是否具有VIP资格。

就是在访问层面做文章，在getter和setter函数里去进行校验和拦截，确保一部分变量是安全的。

ES6中的Proxy本身就是为拦截而生的，目前实现保护代理时，首要方案就是Proxy。



#### 小结：

代理模式的目的十分多样：加强控制、提高性能、优化代码结构、实现功能解耦，等等

但套路就一个：A不能直接访问B，A需要借助一个帮手来访问B，这个帮手就是代理器。

