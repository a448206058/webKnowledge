#### 观察者模式

> 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。——Graphic Design Patterns



#### ~生活中的观察者模式

产品经理把开发测试拉群=》需求还待确定=》开发测试心理上做好准备=》需求确定后产品经理@所有人并上传需求文档=》开发和测试投入工作

##### 重点角色对号入座

观察者模式有一个“别名”，叫`发布 - 订阅模式`（两者之间存在着细微差别），这个别名非常形象地诠释了观察者模式里两个核心的角色要素——**“发布者”与“订阅者”**

上例中，需求文档（目标对象）的发布者只有一个——产品经理，而需求信息的接受者有多个——前端、后端、测试。这些接受者的共性就是需要根据需求开展自己后续的工作、因此都非常关心需求信息，关注群消息提醒，是实打实的**订阅者**，即观察者对象。

一个需求信息对象对应了多个观察者，当需求信息对象的状态发生**变化**（从无到有）时，产品经理通知了群里的所有同学，以便这些同学接收信息进而开展工作：角色划分——>状态变化——>发布者通知到订阅者，这就是观察者模式的“套路”。



#### ~在实践中理解定义

在观察者模式里，至少应该有两个关键角色是一定要出现的——发布者和订阅者。用面向对象的方式表达的话，就是要有两个类。

**代表发布者的类，Publisher**。应该具备的基本技能？拉群（增加订阅者），@所有人（通知订阅者），踢走项目组成员（移除订阅者）

**订阅者，Observer**。能干啥？被通知、去执行（本质上是接受发布者的调用）。在Publisher中做的是方法调用，那么在订阅者类中需要做的就是方法的定义

以上就是最基本的发布者和订阅者类的设计和编写。在实际业务中，所有定制化的发布者/订阅者逻辑都可以基于这两个基本类来改写。如，可以通过拓展发布者类，来使所有的订阅者来监听某个特定状态的变化。如，让开发者们来监听需求文档prd的变化

作为订阅方，开发者的任务也变得具体起来：接收需求文档、并开始干活

我们可以new一个PrdPublisher对象（产品经理），他可以通过调用setState方法来更新需求文档。需求文档每次更新，都会紧接着调用notify方法来通知所有开发者，这就是：

> 目标对象的状态发生改变时，会通知所有观察者对象，使他们能够自动更新。

