#### 结构型：装饰器模式

又名：装饰者模式。定义”在不改变原对象的基础上，通过对其进行包装拓展，使原有对象可以满足用户的更复杂需求“。



##### ~生活中的装饰器

水墨屏手机壳：不会对手机原有的功能产生任何影响，仅仅是使手机具备了一种新的能力（多了块屏幕）。



##### ~装饰器的应用场景

假设初始需求：每个业务中的按钮在点击后都弹出’您还未登录哦‘的弹框。与单例模式例子中的按钮点击类似。

需求变化：弹框不够明显，在弹框打开后把按钮的文案改为”快去登录“，并把按钮置灰。

=》不得不深入到每一个业务的深处去给不同的按钮添加这部分逻辑

=》直接修改已有的函数体，违背了”开放封闭原则“；往一个函数体塞这么多逻辑，违背”单一职责原则“

=》不想关心现有的业务逻辑是怎样的——只想对已有的功能做个拓展，只关心拓展出来的那部分新功能如何实现。



##### ~装饰器模式初相见

为了不被已有的业务逻辑干扰，当务之急就是将新旧逻辑分离，把**旧逻辑抽出去**:

```javascript
function openModal(){}
```

编写新逻辑：

```javascript
function changeButtonText() {}

function disableButton() {}

function changeButtonStatus() {}
```

再把三个操作逐个添加到open按钮的监听函数里。

如此，就实现了”只添加，不修改“的装饰器模式。使用changeButtonStatus的逻辑修饰了旧的按钮点击逻辑。

在ES6中，可以以一种更加面向对象化的方式去写。

**ES6这个版本的实现中，把按钮实例传给了Decorator，以便于后续Decorator可以对它进行逻辑的拓展。**在ES7中，Decorator作为一种语法被直接支持，书写变得更加简单。



##### ~值得关注的细节

**”单一职责原则“**

将不同的职责分离，可以做到每个职责都能被灵活地服用；同时，不同职责之间无法相互干扰。

但是！设计原则并非是规定死的教条。在日常开发中，当遇到两段各司其职的代码逻辑时，首先要有”尝试拆分“的敏感，其次要有”该不该拆“的判断——如果逻辑粒度过小？