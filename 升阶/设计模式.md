## 我们为什么要用到设计模式？
能用健壮的代码去解决具体的问题；
能用抽象的思维去面对复杂的系统；
能用工程化的思想去规划更大规模的业务；

## 面向对象编程和面向对象设计的五个原则：
单一功能原则
开放封闭原则（可扩展，而不可修改）
里氏替换原则（父类可以用子类替换，反过来则不行）
接口隔离原则（要为各个类建立它们需要的专用接口）
依赖反转原则（高层模块不应该依赖于低层模块，俩者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象）；

## 设计模式的核心思想是什么？
封装变化：将变化造成的影响最小化，将变与不变分离，确保变化的部分灵活、不变的部分稳定

## 设计模式有哪几种类型？分别是什么含义？
创造型模式：封装了创建对象过程中的变化，将创建的过程抽离
结构型模式：封装了对象间组合方式的变化，灵活地表达对象间的配合与依赖关系
行为型模式：封装了对象的行为，确保更安全、更方便地对行为进行更改

## JavaScript中常见的设计模式有哪些？
创建型：
    1.工厂模式
    2.抽象工厂模式
    3.单例模式
    4.原型模式
结构型：
    5.装饰器模式
    6.适配器模式
    7.代理模式
行为型：
    8.策略模式
    9.状态模式
    10.观察者模式
    11.迭代器模式
    
## 工厂模式概念是什么？用在哪些地方？
工厂模式就是将创建对象的过程单独封装
在有构造函数的地方就应该想到工厂模式
构造器->解决多个对象实例的问题 工厂模式->解决多个类的问题

```JavaScript
// 构造器
function User(name, age, caree){
    this.name = name;
    this.age = age;
    this.caree = caree;
}

const user = new User('name', 'age', 'caree');

// 工厂模式
// 工厂模式就是将构造器中变与不变剥离开
function User(name, age, caree, work){
    this.name = name;
    this.age = age;
    this.caree = caree;
    this.work = work;
}

function Factory(name, age, caree){
    let work
    switch(caree){
        case 'coder':
              work = ['write code', 'write doc', 'fix bug'];
              break;
            case 'product manager':
              work = ['book meetingroom', 'write PRD', 'push process'];
              break;
            case 'boss':
              work = ['drink tea', 'read paper', 'meet client'];
              break;
            case 'xxx':
              // 其他工种的职责分配
              // ..
    }
    return new User(name, age, caree, work)
}
```

## 抽象工厂模式的概念是什么？用在哪些地方？
抽象工厂模式的定义，是围绕一个超级工厂创建其它工厂
    抽象工厂
    具体工厂
    抽象产品
    具体产品
主要是应用在当工厂变得庞大，为了便于扩展，使用抽象工厂模式
遵循开放封闭原则
```JavaScript
// 抽象工厂
class MobilePhoneFactory {
    // 提供操作系统的接口
    createOS() {
        throw new Error('抽象工厂方法不允许直接调用，需要重写！');
    }
    createHardWare () {
        throw new Error('抽象工厂方法不允许直接调用，需要重写！');
    }
}

// 具体工厂
class FakeStarFactory extends MobilePhoneFactory {
    createOS() {
        return new AndroidOS();
    }
    createHardWare() {
        return new QualCommHardWare();
    }   
}

// 抽象类
class OS {
    controlHardWare(){
        throw new Error('抽象产品方法不允许直接调用，需要重写!');
    }
}

class HardWare {
    operateByOrder() {
        throw new Error('抽象产品方法不允许直接调用，需要重写!');
    }
}

// 具体类
class AndroidOS extends OS {
    controlHardWare(){
        console.log('使用安卓的方式去操作硬件');
    }
}

class AppleOS extends OS {
    controlHardWare() {
        console.log('使用苹果的方式去操作硬件');
    }
}

class QualcommHardWare extends HardWare {
  operateByOrder() {
    console.log('用高通的方式运转');
  }
}

class MiWare extends HardWare {
  operateByOrder() {
    console.log('用小米的方式运转');
  }
}
```

## 单例模式的概念是什么？用在哪些地方？
保证一个类仅有一个实例，并提供一个访问它的全局访问点，这样的模式就叫做单例模式。
基于Flux架构的状态管理工具，无论是Redux或Vuex，都实现了一个全局的Store用于存储应用的所有状态。
要保证一个类仅有一个实例，需要在构造函数中进行判断，或者通过闭包
```JavaScript
SingleDog.getInstance = (function(){
    let instance = null;
    return function(){
        if(!instance){
            instance = new SingleDog();
        }
        return instance;
    }
})();
```

## 原型模式的概念？原型模式用在哪些地方？
原型模式不仅是一种设计模式，更是一种编程范式，是JavaScript面向对象编程的基础
在原型模式下，当创建一个对象时，先找到一个对象作为原型然后通过克隆原型的方式来创建出一个与原型一样（共享一套数据/方法）的对象
Objet.create()是原型模式的天然实现
ES6的类class其实是原型继承的语法糖
```JavaScript
class Dog{
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    
    eat() {
        console.log('')
    }
}

function Dog(name, age) {
    this.name = name;
    this.age = age;
}
Dog.prototype.eat = function(){
    console.log('')
}
```
原型模式其实就是原型范式
原型编程范式的核心思想就是：利用实例来描述对象，用实例作为定义对象和继承的基础

在JavaScript中，原型编程范式的体现就是：基于原型链的继承

原型链：
当试图去访问一个JavaScript实例的属性/方法时，它首先搜索这个实例本身；当发现实例没有定义对应的属性/方法时，它会去搜索实例
的原型对象；如果原型对象中也搜索不到，就去搜索原型对象的原型对象，这个搜索的轨迹，就叫做原型链。

彼此相连的`prototype`组成了一个原型链。

## 装饰器模式的概念是什么？装饰器模式用在哪些地方？
在不改变原对象的基础上，对其进行包装拓展，使原有对象可以满足用户的更复杂的需求。
比如有个未登录的弹框，需要拓展改为按钮置灰，文字改为快去登录，不能点击
遵循单一职责原则
高阶组件

把三个操作逐个添加到open按钮的监听函数中
```JavaScript
function openModal() {

}

function changeButtonText(){}
function disableButton(){}
function changeButtonStatus(){}

// ES6 通过把按钮实例传给 Decorator，方便拓展

function classDecorator(target) {
    target.hasDectorator = true;
    return target;
}

@classDecorator
class Button{

}
console.log(Button.hasDectorator)

function funcDecorator(target, name, descriptor) {
    let orginalMethod = descriptor.value;
    descriptor.value = function() {
        console.log('2222')
        return orginalMethod.apply(this, arguments);
    }
    return descriptor;
}

class Button{
    @funcDecorator
    onClick(){
        console.log('111')
    }
}

const button = new Button();
button.onClick();

//高阶组件
import React, { Component } from 'react'

const BorderHOC = WrappedComponent => class extends Component {
    render() {
        return <div style={{border: 'solid 1px red'}}>
            <WrappedComponent/>
        </div>
    }
}

export default BorderHOC;

import React, { Component } from 'react'
import BorderHOC from './BorderHOC';

//用BorderHOC装饰目标组件
@BorderHOC
class TargetComponent extends React.Component {
    render() {
        // 目标组件具体的业务逻辑
    }
}

export default TargetComponent;
```

## 适配器模式的概念是什么？适配器模式应用在哪些地方？
通过把一个类的接口变成客户端所期待的另一种接口，可以帮我们解决不兼容的问题。
兼容接口


```JavaScript
//fetch

// Ajax适配器函数，入参与旧接口一致
async function AjaxAdapter(type, url, data, success, failed){
    HttpUtils.get(url)
}

async function Ajax(type, url, data, success, failed) {
    await AjaxAdapter(type, url, data, success, failed)
}

// axios

function getDefaultAdapter() {
  var adapter;
  // 判断是否是node环境
  if(typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    adapter = require('./adapters/http');
  } else if(typeof XMLHttpRequest !== 'undefined') {
    // 如果是浏览器环境，调用基于xhr的适配器
    adapter = require('./adapters/xhr');
  }
  return adapter;
}

// http适配器
module.exports = function httpAdapter(config) {
    return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise){
        // 具体逻辑
    });
}

// xhr适配器
module.exports = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject){
        // 具体逻辑
    });
}
```

## 什么是代理模式？代理模式主要用在哪些地方？

    出于某种考虑，一个对象不能**直接访问**另一个对象，需要一个第三者牵线搭桥从而间接达成访问目的，这样的模式就叫做代理模式。
    业务开发中最典型，最实用、最常见的四种代理类型：事件代理、虚拟代理、缓存代理和保护代理
        事件代理：循环点击事件
        虚拟代理：预加载、懒加载图片
        缓存代理：代理进行缓存和求值
        保护代理：进行拦截，是否实名验证
    主要通过Proxy来实现
    代理模式的目的十分多样：加强控制、提高性能、优化代码结构、实现功能解耦

## 什么是策略模式？策略模式主要用在哪些地方？
定义一系列的算法，把它们一个个封装起来，并且使它们可互相替换
算法提取、算法封装、分化优化
主要用在重构，遵循开放封闭原则



最后
这篇文章主要是对设计模式的学习的总结以及输出，加强理解以及记忆
主要学习自掘金修言大佬的设计模式小册
