1. 了解你使用的JavaScript版本
如果你要编写健壮的代码应对各种各样的代码连接，有俩个可选的方案
* 第一个解决方案是不要将进行严格模式检查的文件和不进行严格模式检查的文件连接起来
* 第二个方案是通过将其自身包裹在立即调用的函数表达式中的方式连接多个文件

* 决定你的应用程序支持 JavaScript 的哪些版本 。
* 确保你使用的任何 JavaScript 的特性对于应用程序将要运行的所有环境都是支持的。
* 总是在执行严格模式检查的环境中测试严格代码。
* 当心连接那些在不同严格模式下有不同预期的脚本。

2. 理解JavaScript的浮点数
* JavaScript的数字都是双精度的浮点数
* JavaScript中的整数仅仅是双精度浮点数的一个子集，而不是一个单独的数据类型。
* 位运算符将数字视为32位的有符号整数
* 担心浮点数运算中的精度陷阱。

3. 当心隐式的强制转换
算术运算符 -、*、/ 和 % 在计算之前都会尝试将其 参数转换为数字。而运算符 + 更为微妙，因为它既重载了数字相加，又重载了字符串连接操 作。

但是强制转换也会隐藏错误。结果为 null 的变量在算术运算中不会导致失败，而是被隐 式地转换为 0 ；一个未定义的变量将被转换为特殊的浮点数值 NaN

NaN 是 JavaScript 中唯一一个不等于其自身的值，因此，你可以随时通过检查一个值是否等 于其自身的方式来测试该值是否是 NaN。
* 类型错误可能被隐式的强制转换所隐藏
* 重载的运算符 + 是进行加法运算还是字符串连接操作取决于其参数类型
* 对象通过valueOf方法强制转换为数字，通过toString方法强制转换为字符串
* 具有valueOf方法的对象应该实现toString方法，返回一个valueOf方法产生的数字的字符串表示。
* 测试一个值是否为未定义的值，应该使用typeof或者undefined进行比较而不是使用真值计算。

4. 原始类型优于封装对象
* 当做相等比较时，原始类型的封装对象与其原始值行为不一样。
* 获取和设置原始类型的属性会隐式地创建封装对象。

5. 避免对混合类型使用==运算符
* 当参数类型不同时， ==运算符应用了一套难以理解的隐式强制转换规则。
* 使用 === 运算符，使读者不需要设计任何的隐式转换就能明白你的比较运算。
* 当比较不同类型的值时，使用你自己的显式强制转换使程序的行为更清晰。

6. 了解分号插入的局限
* 仅在"}"标记之前、一行的结束和程序的结束处推导分号。
* 仅在紧接着的标记不能被解析的时候推导分号
* 在以(|、[、+、-或/字符开头的语句前绝不能省略分号。)
* 当脚本连接的时候，在脚本之间显式地插入分号。
* 在return、throw、break、continue、++或--的参数之前绝不能换行
* 分号不能作为for循环的头部或空语句的分隔符而被推导出。

7. 视字符串为16为的代码单元序列
* JavaScript字符串由16位的代码单元组成，而不是由Unicode代码点组成
* JavaScript使用俩个代码单元表示2^16及其以上的Unicode代码点。这俩个代码单元被称为代理对。
* 代理对甩开了字符串元素计数，length、charAt、charCodeAt方法以及正则表达式模式受到了影响。
* 使用第三方的库编写可识别代码点的字符串操作。
* 每当你使用一个含有字符串操作的库时，你都需要查阅该库文档，看它如何处理代码点的整个范围。

8. 尽量少用全局对象
* 避免声明全局变量
* 尽量声明局部变量
* 避免对全局对象添加属性
* 使用全局对象来做平台特性检测

9. 始终声明局部变量
始终使用var声明新的局部变量
* 考虑使用lint工具帮助检查未绑定的变量

10. 避免使用with
* 避免使用with语句
* 使用简短的变量名 代替重复访问的对象
* 显式地绑定局部变量到对象属性上，而不是使用With语句隐式地绑定它们。

11. 熟练掌握闭包
* 函数可以引用定义在其外部作用域的变量
* 闭包比创建它们的函数有更长的生命周期
* 闭包在内部存储其外部变量的引用，并能读写这些变量

12. 理解变量声明提升
* 在代码块中的变量声明会被隐式地提升到封闭函数的顶部
* 重声明变量被视为单个变量
* 考虑手动提升局部变量的声明，从而避免混淆

13. 使用立即调用的函数表达式创建局部作用域
* 理解绑定与赋值的区别
* 闭包通过引用而不是值捕获它们的外部变量。
* 使用立即调用的函数表达式（IIFE）来创建局部作用域
* 当心在立即调用的函数表达式中包裹代码块可能改变其行为的情形。

14. 当心命名函数表达式笨拙的作用域
* 在Error对象和调试器中使用命名函数表达式改进栈跟踪
* 在ES3和有问题的JavaScript环境中谨记函数表达式作用域会被Object.prototype污染
* 谨记在错误百出的JavaScript环境中会提升命名函数表达式声明，并导致命名函数表达式的重复存储。
* 考虑避免使用命名函数表达式或在发布前删除函数名
* 如果你将代码发布到正确实现的ES5环境中，那么你没有什么好担心的。

15. 当心局部块函数声明笨拙的作用域
* 始终将函数声明置于程序或被包含的函数的最外层以避免不可移植的行为
* 使用var声明和有条件的赋值语句替代有条件的函数声明

16. 避免使用eval创建局部变量
* 避免使用eval函数创建的变量污染调用者的作用域
* 如果eval函数代码可能创建全局变量，将此调用封装到嵌套的函数中以防止作用域污染。