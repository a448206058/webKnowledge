// 1． 第一个记忆周期：5分钟
// 2． 第二个记忆周期：30分钟 20201207 19:30
// 3． 第三个记忆周期：12小时 20201208 07:00
// 4． 第四个记忆周期：1天 20201208 19:00
// 5． 第五个记忆周期：2天 20201209 19:00
// 6． 第六个记忆周期：4天 20201211 19:00
// 7． 第七个记忆周期：7天 20201214 19:00
// 8． 第八个记忆周期：15天 20201223


//实现深拷贝和浅拷贝  --1-- 20201208 11:10 --2-- 11:45
//实现浅拷贝
//1.es6 object.assign()
var a = {name: "hello"};
var b = Object.assign({}, a);
b.name = "hi";
console.log(a);
//2. 展开运算符
var a = {name: 'hello'};
var b = { ...a}; //扩展运算符用三个点号表示，功能是把数组或类数组对象展开成一系列用逗号隔开的值
b.name = "hi";
console.log(a);
//for in
var a = {name: 'hello'};
var b = copy(a);
b.name = 'hi';
console.log(a);
function copy(obj) {
    var result = {};
    for (var attr in obj) {
        result [attr] = obj[attr];
    }
    return result;
}
//深拷贝
//1层的
var obj = JSON.parse(JSON.stringify(objs));
//递归实现
function deepCopy ( source ){
    var target = Array.prototype.isArray(source) ? [] : {};
    for ( var k in target){
        if(typeof source[k] === 'object'){
            target[k] = deepCopy(source[k]);
        }else{
            target[k] = source[k];
        }
    }
    return target;
}

//promise的实现
var promise = new Promise((resolve, reject)=>{
    if(true){
        resolve(value)
    }else{
        reject(error);
    }
})
promise.then(function(value){

},function(value){

})

//--1-- 20201208 13:30 --2-- 13:58
function myPromise(constructor){
    var self = this;
    self.status = "pending";
    self.value = undefined;
    self.reason = undefined;
    function resolve(res){
        if(self.status === "pending"){
            res.status = "resolved";
            res.value = res;
        }
    }
    function reject(res){
        if(self.status === "pending"){
            res.status = "rejected";
            res.reason = res;
        }
    }
    try {
        constructor(resolve, reject);
    }catch(e){
        reject(e);
    }
}
myPromise.prototype.then = function(onFullfilled, onRejected){
    var self = this;
    switch(self.status){
        case "resolved":
            onFullfilled(self);
            break;
        case "rejected":
            onRejected(self);
            break;
        default:
    }
}

//手写call2  --1-- 20201208 14:10  --2-- 16:17
//fun.call(thisArg,arg1,arg2,...)，调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。
//call核心：
// 将函数设为对象的属性
// 执行&删除这个函数
// 指定 this到函数并传入给定参数执行函数
// 如果不传入参数，默认指向为 window
Function.prototype.call2 = function(context){
    var context = context || window;
    context.fn = this;
    var args = [];
    for(let i = 1;i < arguments.length;i++){
        args.push('arguments['+i+']');
    }
    var result = eval('context.fn('+args+')');
    delete context.fn;
    return result;
}

//手写apply --1-- 20201208 17:41 --2-- 18:18
Function.prototype.apply2 = function(context, arr){
    var context = Object(context) || window;
    context.fn = this;
    var result;
    var args = [];
    if(!arr){
        result = context.fn();
    }else{
        for(let i = 0;i < arr.length;i++){
            args.push('arr['+i+']');
        }
        result = eval('context.fn('+arr+')')
    }
    delete context.fn;
    return result;
}


/*
    vue知识
    说说你对MVVM的理解： --1-- 20201208 13:50  --2-- 16:28
    model view viewmodel
    模型指的是后端传递的数据 视图指的是页面 视图模型和mvvm的核心 主要有俩个方向
    第一个方向是把模型转换为视图 实现方式是数据绑定
    第二个方向是把视图转换为模型 实现方式是DOM事件监听
    这俩个方向都实现的 我们称之为数据的双向绑定
    总结：模型和视图是通过视图模型建立通信，通常viewmodel 要实现一个observe观察者，
    当数据发生变化时，viewmodel能够监听到这种变化，然后通知数据做改动，这实际上就实现了数据的双向绑定
    viewmodel可以互相通信。

   vue2.x响应式数据/双向绑定原理  --1-- 20201208 17:28 --2-- 18:31

        通过observe监听自己的model数据变化，通过compile来解析编译模板指令，最终利用watcher搭起observer和compile之间的通信桥梁
        达到数据变化 -> 视图更新
        视图交互变化 -> 数据model变更的双向绑定的效果

        监听器observer:对数据对象进行遍历，包括子属性对象的属性，object.defineProperty()对属性都加上setter和getter
        这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到数据变化

        解析器compile:解析vue模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者。
        一旦数据有变动，收到通知，调用更新函数进行数据更新。

        订阅者watcher:watcher订阅者是observer和compile之间通信的桥梁，主要的任务是订阅observer中的属性值变化的消息
        当收到属性值变化的消息时，触发解析器compile中对应的更新函数。每个组件实例都有相应的watcher实例对象，它会在组件渲染的过程中把属性记录为依赖
        之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新-这是一个典型的观察者模式

        订阅器Dep:订阅器采用 发布-订阅 设计模式，用来收集订阅者Watcher，对监听器Observer和订阅者Watcher进行统一管理。

    vue3.x响应式数据原理  --1-- 202012078 11:37
        vue3.x改用proxy替代object.definePrototype
        因为proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。
        proxy只会代理对象的第一层，vue3是怎样处理这个问题
        判断当前Reflect.get的返回值是否为object，如果是则再通过reactive方法做代理，这样就实现了深度观测。
        监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？我们可以判断key是否被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上俩个条件时，
        才有可能执行trigger。

    proxy与object.defineProperty优劣对比
        Proxy的优势如下：
            proxy可以直接监听对象而非属性;
            proxy可以直接监听数组的变化
            proxy有多达13种拦截方法，不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的;
            proxy返回的是一个新对象，我们可以只操作新的对象达到目的，而object.defineProperty只能遍历对象属性直接修改；
            proxy作为新标准将受到浏览器厂商重点持续的性能优化。
        object.defineProperty有事如下：
            兼容性好，支持IE9，而proxy的存在浏览器兼容性问题，而且无法用Polyfill磨平



 */
 
 /*
    vue 3.0
        vue2.x生命周期回顾  --1-- 20201208 10:39  --2-- 11:09
        1.beforeCreate 在实例初始化之后，数据观测(data observer)和event/watcher事件配置之前被调用。
        2.created 在实例创建完成之后立即调用。在这一步，实例已完成以下的配置：数据观测（data observer)，属性和方法的运算，watch/
        event事件回调。然而，挂载阶段还没开始，$el属性目前尚不可用。
        3.beforeMount，在挂载开始之前被调用：相关的render函数首次被调用。
        4.mounted，实例被挂载后调用，这时el被新创建的vm.$el替换类。如果根实例挂载到了一个文档内的元素上
        5.beforeUpdate 数据更新时调用
        6.updated 由于数据更改导致的虚拟DOM重新渲染和打布丁
        7.activated 被keep-alive缓存的组件激活时调用
        8.deactivated 被keep-alive 缓存的组件停用时激活、
        9.beforeDestroy 实例销毁之前调用
        10.destoryed
        11.errorCaptured
   
   vue3.x生命周期变化 --1-- 20201208 10:48  --2-- 11:12
       被替换
           1.beforeCreate -> setup()
           2.created -> setup()
       重命名
           1.beforeMount -> onBeforeMount
           2.mounted -> onMounted
           3.beforeUpdate -> onBeforeUpdate
           4.updated -> onUpdated
           5.beforeDestroy -> onBeforeUnmount
           6.destroyed -> onUnmounted
           7.errorCaptured -> onErrorCaptured
       新增的
           debug回调钩子
           1.onRenderRracked
           2.onRenderTriggered
           
    composition api 核心语法 --1-- 20201208 11:13 --2-- 11:33
        setup 主执行函数
        setup是compisitionAPI的核心，可以说也是整个vue3.x的核心
            setup将vue2.x的beforeCreate和created代替了，以一个setup函数的形式，可以灵活组织代码了
            setup还可以return数据或者template，相当于把data和render也一并代替了
            setup取消了this setup(props, context) 
        reactive方法
            被reactive方法包裹后的对象就变成了一个代理对象，相当于vue2.x中的vue.observable()。也就可以实现页面和
            数据之间的双向绑定了。
            这个包裹的方法是deep的，对所有嵌套的属性都生效。
            const obj2 = reactive({
                cnt: 1
            })
        ref方法
            被ref方法包裹后的元素就变成了一个代理对象。元素指基本元素
            ref一般适用于某个元素，而reactive适用于一个对象
            setup(){
                const count = ref(100)
                
                const count = reactive({
                    value: 100
                })
                
                console.log(count.value)
            }
            在template上使用时，会自动打开unwrap，不需要再加.value
        isRef方法
            判断一个对象是否ref代理对象。
            const unwrapped = isRef(foo ? foo.value : foo)
        toRefs方法
            将一个reactive代理对象打平，转换为ref代理对象，使得对象的属性可以直接在template上使用
        computed函数
            与vue2.x中的作用类似，获取一个计算结果。不仅支持取值get，还支持赋值set。
            注意：结果是一个ref代理对象，js中取值需要.value
            const plusone = computed({
                get: () => count.value + 100,
                set: val => { count.value = val - 1}
            })
        readonly函数
            使用readonly函数，可以把普通object对象、reactive对象、ref对象返回一个只读对象
            
    vue3.x新特性 --1-- 20201208 11:35  --2-- 12:00
        1.compostion api 合成api
        2.取消vue全局变量
            取消了全局变量vue，改为实例函数createApp()创建实例对象。
        3.自定义指令directives api调整
        4 component组件支持v-model指令
            子组件调用父组件的方法通过this.$emit()
            数据双向绑定 .sync修饰符
            vue3.x 直接v-model替代了.sync
        5 fragments template支持有多个根节点
        6 suspense template fallback 组件
            <suspense>
                <template #default>
                </template>
                <template #fallback>
                </template>
            </suspense>
        7 teleport template dom占位传递组件
 */

/*
    算法
        前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？  --1-- 20201208 19:33 --2-- 11:35
        一、为什么引入复杂度分析
            通过计算机运行会受外部影响随机性
        二、如何表示复杂度
            具体来讲就是代码执行的时间、执行消耗的存储空间
        三、时间复杂度 T(n) = O(n)
            仅仅关注代码执行次数最多的那段就可以了
            常量阶：O(1)；当算法中不存在循环语句、递归语句、即使有成千上万行代码，其时间复杂度也是O(1)
            对数阶：O(logn)
                let i = 1;
                while(i <= n){
                    i = i * 2;
                }
                O(log2n)
            线性阶：O(n)
            线性对数阶:O(nlogn)
            非多项式量阶：
            指数阶：O(2^n)
            阶乘阶：O(n!)
        四、空间复杂度
            即i及数组a占用的储存空间 O(n)

        从chrome v8源码看javascript数组  --1-- 20201208 11:58
        数组、链表、栈、队列都是线性表，它表示的结构都是一段线性的结构，与之对应的就是非线性表
        例如树、图、堆等，它表示的结构都是非线性。
        一、数组
            一种最基础的数据结构，代表一组连续的储存结构，用来储存同一种类型的数据
            优点
                随机访问：可以通过下标随机访问数组中的任意位置上的数据
            缺点
                对数据的删除和插入不是很友好
            查找：根据下标随机访问的时间复杂度为O(1);
            插入或删除：时间复杂度为O(n)
       二、javascript中，数组可以保存不同类型值
       三、javascript中，数组的存储
       四、javascript中，数组的动态扩容与减容
       五、总结
           javascript中,jsarray继承自jsobject,数组是一个特殊的对象，内部是以key-value形式存储数据，所以javascript中的数组
           可以存放不同类型的值。它有俩种存储方式，快数组与慢数组，初始化空数组时，使用快数组，快数组使用连续的内存空间，当数组长度达到最大时，
           jsarray会进行动态的扩容，以存储更多的元素，相对慢数组，性能要好的多。当数组中hole太多时，会转变成慢数组，即以哈希表的
           方式存储数据，以节省内存空间。
           
           //数组扁平化
           var flatArr = arr.flat(4)
           //去重
           var disArr = Array.from(new Set(flatArr))
           //排序
           let result = disArr.sort(function(a, b){
               return a - b
           })
 */


/*
    typescript 对象 --1-- 20201208 09:54 --2-- 10:26
    对象是包含一组键值对的实例。值可以是标量、函数、数组、对象等。
    对象实例
    typescript类型模板
    鸭子类型 是动态类型的一种风格，是多态的一种形式
    一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由"当前方法和属性的集合"决定

    typescript命名空间 --1-- 20201208 09:55 --2-- 10:27
        命名空间一个最明确的目的就是解决重名问题
        使用namespace来定义
        namespace SomeNameSpaceName {
            export interface ISomeInterfaceName { }
            export class SomeClassName { }
        }
        以上定义了一个命名空间somenamespacename,如果我们需要在外部可以调用someNamespace和接口，则需要在类和接口添加export关键字
        嵌套命名空间
            命名空间支持嵌套，即你可以将命名空间定义在另外一个命名空间里头。
            namespace namespace_name1 {
                export namespace namespace_name2 {
                    export class class_name { }
                }
            }

    typescript模块 --1-- 20201208 10：10 --2-- 10:27
        typescript模块的设计理念是可以更换的组织代码。
        模块是在其自身的作用域里执行，并不是在全局作用域，这意味着定义在模块里面的变量、函数和类等在模块外部是不可见的，
        除非明确地使用export导出它们。类似地，我们必须通过import导入其他模块导出的变量、函数、类等。
        俩个模块之间的关系是通过在文件级别上使用import和export建立的。
        模块使用模块加载器去导入其它的模块。

        模块导出使用关键字export关键字
        export interface SomeInterface {
        }
        要在另外一个文件使用该模块就需要使用import关键字来导入
        import someInterfaceRef = require("./SomeInterface");

    typescript声明文件 --1-- 20201208 10:10 --2-- 10:28
        引用javascript的库需要将这些库里的函数和方法体去掉后只保留导出类型声明，而产生了一个描述javascript库和模块信息的声明文件。
        通过引用这个声明文件，就可以借用typescript的各种特性来使用库文件了。
        声明文件
        declare var jQuery: (selector: string) => any;
        jQuery('#foo');
        declare定义的类型只会用于编译时的检查，编译结果中会被删除
*/
