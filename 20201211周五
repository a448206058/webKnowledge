// 1． 第一个记忆周期：5分钟
// 2． 第二个记忆周期：30分钟 20201211 19:30
// 3． 第三个记忆周期：12小时 20201212 07:00
// 4． 第四个记忆周期：1天 20201212 19:00
// 5． 第五个记忆周期：2天 20201213 19:00
// 6． 第六个记忆周期：4天 20201215 19:00
// 7． 第七个记忆周期：7天 20201218 19:00
// 8． 第八个记忆周期：15天 20201226

/*
    手写代码
        深度优先遍历、广度优先遍历
            简单来说深度优先就是自上而下的遍历搜索 广度优先则是逐层遍历
            俩者的区别
                1.深度优先不需要记住所有的节点，所以占用空间小，而广度优先需要先记录所有的节点占用空间大
                2.深度优先有回溯的操作所以相对而言时间会长一点
                深度优先采用的是堆栈的形式，即先进后出
                广度优先则采用的是队列的形式，即先进先出
            深度优先遍历 DFS   20201211 15:15 --1-- 15:36 --2-- 15:56  --4-- 20201212 19:30 --5-- 20201213 20:05
            //递归
            function DFS1(node, nodeList = []){
                if( node != null){
                    nodeList.push(node);
                    let children = node.children;
                    for (let i = 0; i < children.length;i++){
                        DFS1(children[i], nodeList)
                    }
                }
                return nodeList
            }
            function DFS2(node) {
                let nodeList = [];
                if (node) {
                    //栈 后进先出
                    let stack = [];
                    stack.push(node);
                    while (stack.length){
                        let _node = stack.pop();
                        nodeList.push(_node);
                        let children = _node.children;
                        for (let i = children.length - 1;i >= 0;i--){
                            stack.push(children[i]);
                        }
                    }
                }
                return nodeList;
            }
            let nodeList = DFS1(node);


            //广度优先 递归算法  20201211 15:43 --1-- 16:00 --2-- 16:10

            function BFS1(node){
                var nodes = [];
                var i = 0;
                if (!(node == null)){
                    nodes.push(node);
                    BFS1(node.nextElementSibling);
                    node = nodes[i++];
                    BFS1(node.firstElementChild);
                }
                return nodes;
            }

            function BFS2(node) {
                var nodes = [];
                if (node != null){
                    var queue = [];
                    queue.unshift(node);
                    while (queue.length != 0) {
                        var item = queue.shift();
                        nodes.push(item);
                        var children = item.children;
                        for (var i = 0; i < children.length;i++){
                            queue.push(children[i]);
                        }
                    }
                }
                return nodes;
            }
 */

/*
    vue知识
        diff算法说一下  20201211 16:15 --1-- 16:20 --2-- 16:43 --4-- 20201212 19:45 --5-- 20201213 20:13
            同级比较，再比较子节点；
            先判断一方有子节点一方没有子节点的情况（如果新的children没有子节点，将旧的子节点移除）
            比较都有子节点的情况（核心diff)
            递归比较子节点

       说说你对keep-alive组件的了解  20201211 16:20 --1-- 16:24 --2-- 16:45 --4-- 20201212 19:46 --5-- 20201213 20:15
            keep-alive是vue内置的一个组件，可以使被包含的组件保留状态，避免重新渲染
            有以下特性：
                一般结合路由和动态组件一起使用，用于缓存组件
                提供include和exclude属性，俩者都支持字符串或正则表达式
                include标识只有名称匹配的组件会被缓存，exclude表示任何名称匹配的都不会被缓存，其中exclude比include优先级搞

       说说你对SSR的了解  20201211 16:26 --1-- 16:36 --2-- 16:46. --4-- 20201212 19:47. --5-- 20201213 20:16
            SSR也就是服务端渲染，也就是将VUE在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端
            SSR的优势：更好的SEO；首屏加载速度更快
            SSR的缺点：开发条件会受到限制，服务器端渲染只支持beforeCreate和created俩个钩子
            当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node环境
            更多的服务端负载；

       都做过哪些vue性能优化？ 20201211 16：48  --1-- 16:53 --2-- 17:20 --4-- 20201212 19:48 --5-- 20201213 20:18
            尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher；
            v-if和v-for不能连用；
            如果需要使用v-for给每项元素绑定事件时使用事件代理；
            在更多的情况下，使用v-if替代v-show
            key保证唯一
            使用路由懒加载、异步组件
            防抖、节流
            第三方模块按需导入
            长列表滚动到可视区域动态加载；
            图片懒加载

            SEO优化：预渲染；服务端渲染SSR
            打包优化：压缩代码、使用CDN加载第三方模块；多线程打包happypack，splitChunks抽离公共文件；sourceMap优化
            用户体验：骨架屏；PWA；还可以使用缓存，服务端开启GZIP压缩等；

        vue2.x中如何监控数组变化？ 20201211 17:18 --1-- 17:21 --2-- 17:43. --4-- 20201212 19:50. --5-- 20201213 20:19
            使用了函数劫持的方式，重写了数组的方法，vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法，当调用数组api时，
            可以通知依赖更新。
            如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监控数组变化。

        说说你对SPA单页面的理解，它的缺点是什么？  20201211 17:48 --1-- 20201211 20:35 --2-- 20201211 20:48 --4-- 20201212 19:53
            --5-- 20201213 20:23
            SPA仅在web页面初始化时加载相应的HTML、JavaScript和CSS
            一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现HTML内容的变换，UI与用户的交互，
            避免页面的重新加载。
            优点：用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
            基于上面一点，SPA相对对服务器压力小；
            前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理。
            缺点：初次加载耗时多：为实现单页web应用及显示效果，需要在加载页面的时候javascript、css统一加载，部分页面按需加载；
            前进后退路由管理：由于单页面应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
            SEO难度较大：由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势。

        对于即将到来的vue3.0特性你有什么了解的吗？ 20201211 20:46 --4-- 20201212 19:55 --5-- 20201213 20:23
            监控机制的改变：
                3.0将带来基于代理proxy的observer实现，提供全语言覆盖的反应性跟踪；
                消除了vue2当中基于object.defineProperty的实现所存在的很多限制
                只能检测属性，不能监测对象；
                监测属性的添加和删除；
                检测数组索引和长度的变更；
                支持Map、Set、WeakMap和WeakSet.
            模板：
                 模板方面没有大的变更，只改了作用域插槽，2.x的机制导致作用域插槽变了，父组件会重新渲染，而3.0把作用域插槽改成了函数的方式，
                 这样只会影响子组件的重新渲染，提升了渲染的性能。
                 同时，对于render函数的方面，vue3.0也会进行一系列更改来方便习惯直接使用api来生成vdom
            对象式的组件声明方式：
                vue2.x的组件是通过声明的方式传入一系列option和typescript的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。
                3.0修改了组件的声明方式，改成类式的写法，这样使得和typescript的结合很容易
            其它方面的更改：
                支持自定义渲染器，从而使得weex可以通过自定义渲染器的方式来扩展，而不是直接fork源码来改的样式
                支持fragment和protal组件，根据做了一些特殊的场景做了处理
                基于tree shaking优化，提供了更多的内置功能.
 */
 
 
 /*
    算法
        爬楼梯
            假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
            每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
            注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

     解题思路 fn = f(n-1) + f(n-2)
     
     var climbStairs = function(n) {
         if(n < 0) return 0;
         if(n == 1) return 1;
         if(n == 2) return 2;
         var a = 1;
         var b = 2;
         var temp = 0;
         for(let i = 3;i <=n;i++){
             temp = a + b;
             a = b;
             b = temp;
         }
         return temp;
     }
 */
