// 1． 第一个记忆周期：5分钟
// 2． 第二个记忆周期：30分钟 20201212 19:30
// 3． 第三个记忆周期：12小时 20201213 07:00
// 4． 第四个记忆周期：1天 20201213 19:00
// 5． 第五个记忆周期：2天 20201214 19:00
// 6． 第六个记忆周期：4天 20201216 19:00
// 7． 第七个记忆周期：7天 20201219 19:00
// 8． 第八个记忆周期：15天 20201227

/*
    基础知识
        原型和原型链  20201212 14:11 --1-- 14:21 --2-- 20201212 14:40  --3-- 20201213 08:25 --4-- 20201213 20:27
                prototype 和 __proto__
                每个构造函数都有一个prototype属性，用于指向构造函数的原型对象，这个属性是一个对象数据类型
                    原型对象：构造函数的实例，用于实现继承
                    原型对象中的constructor属性 指向构造函数自身
                每个对象都有一个__proto__属性，用于指向创建它的构造函数的原型对象
            原型链：
                每个对象都有一个__proto__属性，指向创建它的构造函数的原型对象，而原型对象又有自己的原型对象，就这样层层往上
                直到一个对象的原型为null
                这个查询路径就是原型链
            hasOwnProperty是javascript中唯一处理属性并且不会遍历原型链的方法

        什么是闭包？ 20201212 14:40 --1-- 14:48 --2-- 15:06  --3-- 20201213 08:28 --4-- 20201213 20:30
            function(){
                return function(){
                }
            }
            能够读取其它函数内部变量的函数，就是闭包
            作用：
                1.从外部读取函数内部的变量
                2.将创建的变量的值始终保持在内存中
                3.封装对象的私有属性和私有方法

        谈一下js中的作用域链?  20201212 14:49 --1-- 14:54 --2-- 15:20 --3-- 20201213 08:30 --4-- 20201213 20:33
            函数内部指向函数外的链式结构，称为作用域链

        介绍下Set、Map、WeakSet和WeakMap的区别？  20201212 15:15 --1-- 15:20 --2-- 15:41  --3-- 20201212 08:32 --4-- 20201213 20:33
            set:集合
                成员唯一、无序且不重复
                [value,value]只有键值，没有键名
                可以遍历
            weakset
                成员都是对象
                成员都是弱引用，可以被回收，可以用来保存DOM节点
                不能遍历
            map字典
                本质上键值对的集合，类似集合 [key, value]
                可以遍历，方法很多可以跟各种数据类型转换
            weakmap:
                1.只接受对象作为键名
                2.键名是弱引用
                3.不能遍历 方法有get、set、has、delete

        介绍js的基本数据类型 20201212 15:43 --1-- 15:49 --2-- 16:08 --3-- 20201213 08:34. --4-- 20201213 20:38
            null、undefined、object、number、boolean、string symbol
            symbol 表示独一无二的值，最大的用法是用来定义对象的唯一属性名
                let sy = Symbol("key1")
                let syObject = {};
                syObject[sy] = "kk"

        js有哪些内置对象？ 20201212 15:56 --1-- 16:02 --2-- 16:25  --3-- 20201213 08:35 --4-- 20201213 20:39
            数据封装类对象：Object、Array、Boolean、Number和String
            其它对象：Function、Arguments、Math、Date、RegExp、Error

        this对象的理解 20201212 16:11 --1-- 16:17 --2-- 16:37  --3-- 20201213 08：40 --4-- 20201213 20:40
            this总是指向函数的直接调用者；如果有new关键字，this指向new出来的那个对象
            在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象window

        eval是做什么的？ 20201212 16:17 --1-- 16:24 --2-- 16:51 --3-- 20201213 08:43 --4-- 20201213 20:41
            它的功能是把对应的字符串解析成js代码并运行

        对promise的理解？ 20201212 16:27  --1-- 16:32 --2-- 16:52 --3-- 20201213 08:44 --4-- 20201213 20:41
            简单来说是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作的结果，
            从语法上来说，promise是一个对象，从它可以获取异步操作的消息，promise提供了统一的API，各种异步操作都可以用同样的方法来进行处理。
            promise对象是一个构造函数，用来生成promise实例
            promise对象会返回对象内异步操作的状态，我们可以根据状态进行后续操作 异步成功.then 进行回调操作 异步失败 .cache进行错误提示获取其它

        javascript对象的几种创建方式 --4-- 20201213 20:41
            1.工厂模式
                function createObj(name){
                    var o = new Object();
                    o.name = name;
                    return o;
                }
                var obj = createObj('cc');
                缺点：对象无法识别，因为所有的实例都指向一个原型

            2.构造函数模式
                function Person1(name){
                    this.name = name;
                }
                var person1 = new Person1();
                优点：实例可以识别为一个特定的类型
                缺点：每次创建实例时，每个方法都要被调用一次

            3.原型模式
                function Person(){
                }
                Person.protoype.name ='';

                var person1 = new Person();
                优点：方法不会重新创建
                缺点：1.所有的属性和方法都共享 2.不能初始化参数

            4.混合构造函数和原型模式
                function Person(){
                }
                Person.prototype = {
                    constructor = Person,
                }
                var person1 = new Person();
                优点：该共享的共享，该私有的私有，使用最广泛的方式
                缺点：没有更好的封装性

            5.动态原型模式
                function Person(name){
                    this.name = name;
                    if (typeof this.getName != 'function'){
                        Person.prototype.getName = function(){

                        }
                    }
                }

            6.寄生构造函数模式
                function Person(){
                    var o = new Object();
                    return o;
                }
                var person = new Person();

            7.稳妥构造函数模式
                function Person(){
                    var o = new Object();
                    return o;
                }
                var person1 = person('kevin')

        事件循环机制  20201212 22:15 --1-- 22:29  --2-- 22:48  --3-- 20201213 08:47 --4-- 20201213 20:43
            javascript是单线程的，为了不让用户长时间等待，就让长时间请求的程序代码挂起，让用户先操作其他事情
            javascript中任务分为同步任务和异步任务
            任务进入执行栈之后会判断一下是否是同步任务，若是同步任务就会进入主线程执行；异步任务就会到事件表里注册，当指定的事情完成式回调函数到事件队列。这个过程不断循环就是
            就是事件循环。
            
        宏任务和微任务 20201212 22:32  --1-- 22:37 --2-- 23:22 --3-- 20201213 08:51 --4-- 20201213 20:44
            异步任务包含宏任务和微任务，他们会加在同一个队列里面，只是执行顺序不一样而已。
            宏任务：整体代码script、setTimeout、setInterval、setImmediate
            微任务：原生promise中then方法、process.nextTick、MutationObserver
            微任务先于宏任务执行 如果宏任务中有微任务 会先执行完微任务再执行宏任务

        JS垃圾回收 20201212 22:45 --1-- 22:50 --2-- 23：25  --3-- 20201213 08:51 --4-- 20201213 20:47
            js具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存
            引用计数：
                跟踪记录每个值被引用的次数，如果次数为0则回收
            标记清除：
                就是当变量进入执行环境的时候标记为”进入环境“，离开执行环境的时候标记为”离开环境“
 */
 /*
    算法 20201212 23:21 --3-- 20201213 08:54
    母牛生母牛
    问题描述：母牛每年生一只母牛，新出生的母牛成长三年后也能每年生一只母牛，假设不会死。求 N年后，母牛的数量。
    f(n)= f(n-1) + f(n-3)
    Function cow(n){
	    if (n < 1) return;
	    let count = 0;
	    if(n > 4){
		    count = cow(n -1) + cow(n - 3);
	    } else {
		    count = n;
	    }
	    return count;
    }
    
 */
