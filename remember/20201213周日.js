// 1． 第一个记忆周期：5分钟
// 2． 第二个记忆周期：30分钟 20201213 19:30
// 3． 第三个记忆周期：12小时 20201214 07:00
// 4． 第四个记忆周期：1天 20201214 19:00
// 5． 第五个记忆周期：2天 20201215 19:00
// 6． 第六个记忆周期：4天 20201217 19:00
// 7． 第七个记忆周期：7天 20201220 19:00
// 8． 第八个记忆周期：15天 20201228

/*
    基础知识
      设计模式  20201213 09:05 --1-- 09:14 --2-- 09:34  --4-- 20201214 18:07
        工厂模式
        单例模式  单例模式就是保证一个类仅有一个实例，并提供一个访问它的全局访问点
        适配器模式
        代理模式
        发布-订阅模式
        策略模式
        迭代器模式 迭代器模式是指提供一种按顺序访问的方法

      js内存  20201213 09:35 --1-- 09:40 --2-- 10:00  --4-- 20201214 18:07
        JS内存空间分为栈（后进先出）、堆、池
        栈内存中存放基本类型（undefined、null、boolean、number、string、symbol),占用固定大小的空间，通过按值来访问
        堆中存放引用类型，先从栈中读取内存地址，然后再通过地址找到堆中的值
        闭包中的变量并不保存在栈内存中，而是保存在堆内存中

     进程与线程的区别 20201213: 09:40 --1-- 09:49 --2-- 10:07 --4-- 20201214 18:09
        进程是系统进行资源分配和调度的一个独立单位
        线程是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位
        一个进程至少有一个线程组成
        线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源，但是它可与同属一个进程的其他的线程共享进程所有的全部资源

     进程间通信方式 20201213 09:47 --1-- 09:56 --2-- 10:21 --4-- 20201214 18:14
        管道通信
        消息队列通信
        信号量通信
        共享内存通信
        套接字通信

     二叉树 20201213 09:59 --1-- 10:04  --2-- 10:37 --4-- 20201214 18:17
        是每个节点最多有俩个子树的有序树
        二叉树每一个节点不能多于俩个孩子
        没有孩子的节点就是叶子节点
        一个节点有左右俩个指针，若无则指向null
        深度为h的二叉树最多有2^h-1个结点，最少有h个节点
        二叉树的遍历三种方式
          1.前序遍历(DLR) 根-左-右
          2.中序遍历(LDR) 左-根-右
          3.后续遍历(LRD) 左-右-根

     常用git指令 20201213 10:05  --1-- 10:08 --2-- 10:38 --4-- 20201214 18:18
        git clone 下载一个项目和它的整个代码历史
        git add 添加指定目录到暂存区
        git commit 提交暂存区到仓库区
        git push 同步到远程仓库
        git branck 列出所有本地分支
        新建一个分支 并切换到该分支 git checkout -b

     BFC/IFC   20201213 11:07 --1-- 11:13  --2-- 12:01 --4-- 20201214 18:25
        BFC（Block Formatting Context)叫做块级格式化上下文
          如何生成BFC
            根元素
            float的值不为none
            overflow的值不为visible
            display的值为inline-block、table-cell、flex、inline-flex
            position的值为absolute或者fixed
          BFC的布局规则
            内部的元素会在垂直方向上一个接一个的放置
            Box垂直方向的距离由margin决定
            同属一个BFC的俩个相邻box的margin会发生重叠
         应用
            解决margin重叠的问题
            俩栏布局问题
            解决浮动元素的父元素高度坍塌问题
        触发条件
          float的属性不为none
          position为absolute或fixed
          display为inline-block、table-cell、table-caption、flex
          overflow不为visible
        IFC叫做行级格式化上下文
          内部的盒子会在水平方向，一个个地放置
          IFC的高度，由里面最高盒子的高度决定
          当一行不够放置的时候会自动切换到下一行

    常见的布局方式有哪些 20201213 11:15  --1-- 11:19  --2-- 12:03 --4-- 20201214 18:28
        圣杯布局：是一种三栏布局，俩边定宽，中间宽度子适应
        双飞翼布局
        珊格布局
        flex布局
        grid网格布局
        决定定位布局

    css3的filter属性详解 20201213 11:24 --1-- 12:06 --2-- 12:26 --4-- 20201214 18:40
        blur 高斯模糊
        brightness 亮度
        contrast 对比度
        grayscale 灰度滤镜
        hue-rorate 色调旋转
        invert 反色
        opacity 透明度
        saturate 饱和度滤镜
        sepia 褐色

    css的继承属性  20201213 12:09  --1-- 12:14  --2-- 12:36 --4-- 20201214 18:49
        font-size
        text-indent
        text-align
        text-shadow
        line-height
        visibility
        cursor

    CSS盒模型 20201213 12:15 --1-- 12:19 --2-- 13:55 --4-- 20201214 18:52
        w3c标准盒模型：属性width,height只包含内容content，不包括border和padding
        IE盒模型：属性width，height包含border和padding，指的是content+padding+border
        content-box border-box

    CSS权重 20201213 12:18 --1-- 12:22  --2-- 13:57 --4-- 20201214 18:53
        内联样式 id选择器 类选择器 标签选择器和伪元素选择器

    CSS优化技巧 20201213 12:23 --1-- 12:27 --2-- 13:58 --4-- 20201214 18:53
        合理使用选择器
        减少DOM操作，减少重绘和重排
        去除无效的选择器
        文件压缩
        异步加载文件
        减少@import的使用

    css3有哪些新特性？20201213 12:36 --2-- 13:59 --4-- 20201214 18:57
        RGBA和透明度
        background-image background-origin background-size background-repeat
        word-wrap
        transform
        文字阴影 text-shadow
        font-face 定义自己的字体
        border-radius
        box-shadow
        媒体查询

    1像素边框问题 20201213 12:41 --2-- 14:00 --4-- 20201214 19:02
        通过transfrom:scale(0.5)或者通过viewport+rem解决

    分析比较opacity:0 visibility:hidden display:none 优劣和适用场景 20201213 14:12  --1-- 14:21 --4-- 20201214 19:02
        结构：
          display:none 会让元素完全从渲染树中消失，渲染的时候不占据任何空间，不能点击
          visibility:hidden 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见
          opacity: 0 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击
        继承：
          display: none和opacity: 0 是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示
          visibility: hidden 是继承属性，子孙节点消失由于继承了hidden，通过设置visibility:vibible,可以让子节点显示显示
        性能：
          display:none 修改元素会造成文档回流，读屏器不会读取display:none 元素内容，性能消耗较大
          visibility:hidden 修改元素只会造成本元素的重绘，性能消耗较少
          opacity:0 修改元素会造成重绘，性能消耗较少

    重绘和回流 20201213 14:35 --1-- 14:42 --2-- 15:04 --4-- 20201214 19:04
      回流：
        节点的几何属性或者布局发生改变被称为回流
      重绘：
        节点的样式改变且不影响布局的，比如color，visibility等，称为重绘
        重绘不一定引发回流，回流一定引发重绘
      减少回流和重绘：
        批量修改dom或者样式
        避免触发同步UI渲染
        对于复杂动画效果，使用绝对定位让其脱离文档流

    用css实现多行文本溢出省略效果 20201213 14:48 --1-- 15:02 --2-- 15:19 --4-- 20201214 19:06
      单行
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      多行
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 3;
        overflow: hidden;

    如何实现骨架屏，说说你的思路 20201213 14:50  --1-- 14:57  --2-- 15:06 --4-- 20201214 19:17
      使用一张图片，取到数据之后再替换为dom节点

    CSS3新增伪类有哪些？20201213 14:56 --1-- 15:01  --2-- 15:13 --4-- 20201214 19:17
      :first-of-type 选择属于其父元素的首个元素
      :last-of-type 选择属于其父元素的最后元素
      :only-of-type 选择属于其父元素唯一的元素
      :only-child 选择属于其父元素的唯一子元素
      :nth-child 选择属于其父元素的第二个子元素
      :enabled :disabled 表单控件的禁用状态
      :checked 单选框或复选框被选中

   什么是响应式设计？ 20201213 15:03 --1-- 15:07  --2-- 15:30 --4-- 20201214 19:19
      响应式设计是一个网站能够兼容多个终端。
      基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。
      页面头部必须有meta生命的viewport

   阐述一下css sprites  20201213 15:14 --1-- 15:20 --2-- 16:06 --4-- 20201214 19:21
      将一个页面涉及到的所有图片都包含到一张大图中去，然后利用css的background-image，background-repeat,
      backgroun-position的组合进行背景定位。利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能

   不同浏览器的标签默认的外补丁和内补丁不同 20201213 15:22 --1-- 15:30 --2-- 16:07 --4-- 20201214 19:24
      解决方案：css里增加通配符*{margin: 0;padding: 0);

   清除浮动 20201213 15:28 --1-- 15:38 --2-- 16:07 --4-- 20201214 19:22
      添加一个空白标签 内容为clear:both
      父级添加overflow方法：可以通过触发BFC的方式清除浮动
      使用after伪元素清除浮动 cleat:both
      使用zoome: 1

   双边距问题：在IE6中设置了float,同时又设置margin,就会出现双边距问题 20201213 15:36  --2-- 16:09 --4-- 20201214 19:23
      解决方案：设置display: inline;

   浏览器输入一个地址。到页面展示中间经历了哪些东西？ 20201213 16:12  --1-- 16:22 --2-- 16:38 --4-- 20201214 19:24
      1.浏览器检查地址是否合法
      2.查看是否有缓存，如果有缓存，则读取缓存
      3.在发起http请求前，进行dns解析，即域名解析出对应的IP地址
      4.浏览器向服务器发起TCP连接，经历三次握手
      5.客户端向服务端发起请求，请求数据包
      6.服务端接受到请求，将数据返回浏览器
      7.客户端收到http响应
      8.浏览器解析响应。如果响应可以缓存，则存入缓存
      9.浏览器发送请求获取嵌入在HTML中的资源
      10.浏览器发送异步请求
      11.页面全部渲染结束

   常见的浏览器内核有哪些？ 20201213 16:20 --1-- 16:30 --2-- 16:49 --4-- 20201214 19:27
      chrome blink webkit
      firefox gecko
      safari webkit
      edge edgeHTML
      IE trident
      phantomJS webkit

   浏览器是如何渲染UI的？ 20201213 16:29 --1-- 16:36  --2-- 16:59 --4-- 20201214 19:29
      浏览器获取HTML文件，然后对文件进行解析，形成DOM tree
      与此同时，进行CSS解析，生成style rules
      接着将dom tree与style rules合成render tree
      接着进入布局layout阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标
      随后调用GPU进行绘制（paint），遍历render tree的节点，并将元素呈现出来

   DOM Tree是如何构建的？20201213 16:47 --1-- 16:51 --2-- 17:18 --4-- 20201214 19:31
      转码：浏览器将接收到的二进制数据按照指定编码格式转化成HTML字符串
      生成Tokens:之后开始parser，浏览器会将HTML字符串解析成Tokens
      构建Nodes:对Node添加特定的属性，通过指针确定Node的父、子、兄弟关系和所属treeScope
      生成DOM Tree:通过node包含的指针确定的关系构建出dom

   什么是同源策略？20201213 16：48 --1-- 16:55 --2-- 17:21 --4-- 20201214 19:37
      域名、协议、端口号相同

   浏览器缓存 20201213 17:08 --1-- 17:22 --2-- 17:40 --4-- 20201214 19:39
      memory cache  指内存中的缓存 是响应速度最快的一种缓存 缺点是缓存时间短，关闭页面就不存在了
      service worker cache 是一种独立于主线程之外的javascript线程。可以用来实现离线缓存、消息推送以及网络代理等功能
      disk cache 硬盘缓存
      push cache 推送缓存 是http2中的内容，仅存在于会话阶段

   缓存策略 20201213 17:25 --1-- 17:36 --2-- 17:50 --4-- 20201214 19:13
      强缓存
        强缓存是利用http头中的expires和cache-control俩个字段来控制的
        expires是一个时间戳、cache-control是一个时间长度
      协商缓存
        协商缓存依赖于服务端与浏览器之间的通信
        last-modified和etag
        last-modified是一个时间戳
        etag是由服务器为每个资源生成的唯一标识字符串

   BOM对象模型  20201213 17:36 --1-- 17:41  --2-- 19:09 --4-- 20201214 19:45
      是浏览器对象模型
        window对象 表示浏览器打开的窗口
        screen 包含有关用户屏幕的信息
        navigator 包含有关访问者浏览器的信息
        location 用户获取当前页面的地址
        document
        history 包含浏览器的历史

   如何实现跨域？ 20201213 17:52 --2-- 19:09 --4-- 20201214 19:45
      jsonp
      cors
      nginx 反向代理
        所有的客户端的请求都必须经过nginx的处理，nginx作为代理服务器再将请求转发
      window.name
      document.domain 二级域名相同的情况下
      postMessage+iframe

   cookie与session 20201213 17:59 --2-- 19:10 --4-- 20201214 19:53
      cookie保存在客户端；session保存在服务端；
      session是由应用服务器维持的一个服务端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID，用该SessionID
      为标识符来存取服务端的Session存储空间


   webpack的作用 20201213 22:12 --1-- 22：20  --2-- 22:40 --4-- 20201214 19:41
      1.代码转换
      2.文件优化
      3.代码分割
      4.模块合并
      5.自动刷新
      6.代码校验
      7.自动发布

   打包原理 20201213 22:23  --1-- 22:29 --2-- 22:50 --4-- 20201214 19:57
      1.初始化参数：从配置文件和shell语句中读取与合并参数，得到最终的参数；
      2.开始编译：用上一步得到的参数初始化compiler对象，加载所有配置的插件，通过执行对象的run方法开始执行编译；
      3.确定入口：根据配置中的entry找出所有入口文件
      4.编译模块：从入口文件出发，调用所有配置的loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过来本步骤的处理；
      5.完成模块编译：在经过第4步使用loader翻译完所有模块后，得到来每个模块被翻译后的最终内容及它们之间的依赖关系；
      6.输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，再将每个chunk转换成一个单独的文件加入输出列表中，这是可以修改输出内容的最后机会。
      7.输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中；

  loader与plugin的区别  20201213 22:39  --1-- 22:44 --2-- 23:01 --4-- 20201214 19:59
      loader，它是一个转换器，文件内容进行翻译，比如将es6转换为es5，单纯的文件转换过程
      plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不是直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，
      并且执行相对应的任务

  happypack的原理 20201213 22:49 --1-- 22:56 --4-- 20201214 20:03
      webpack中最耗时的就是loader的转换过程，转换的流程很长。happypack的原理就是把这部分的任务拆解成多个子进程去并行处理，减少构建事件
      通过new happypack()实例化，然后把任务交由实例统一调度分配。核心调度器会将一个个任务分配给空闲的子进程。处理完毕后发送给核心调度器。

  如何优化webpack配置 20201213 23:07 --4-- 20201214
      缩小文件查找范围
        优化load
        优化resolve.modules
        优化resolve.mafinFields
        优化resolve.alias
        优化resolve.extensions
        优化module.noPaese
      使用DLLPlugin
        基础模块抽离，打包到动态链接库
        需要使用模块，直接去动态链接库查找
      使用happypack 单线程变多线程
      使用paralleIUglifyPlugin
        开启多进程压缩代码，并行执行
      使用CDN加速
        静态资源放到cdn服务器上面
      tree shaking
        删除无用的代码
      提取公共代码
        防止相同资源重复加载
        减少网络流量及服务器成本
      使用prepack
        编译代码时提前计算结果放到编译后的结果中，而不是在代码运行才求值
 */
/*
   算法
       排序算法
           快速排序 nlogn 20201213 21:34
               基本思想就是分治法的思想，寻找中间点，并对其左右的序列递归进行排序，直到左右都排序完成
               function quickSort(arr){
   if(arr.length==0){
       return arr
   }
   var pirotIndex=Math.floor(arr.length/2)
   var pirot = arr.splice(pirotIndex,1)[0]
   var left=[],right=[]
   for(var i=0;i<arr.length;i++){
       if(arr[i]>pirot){
           right.push(arr[i])
       }else{
           left.push(arr[i])
       }
   }
   return quickSort(left).concat(pirot,quickSort(right))
}
           选择排序 n^2
           插入排序 n^2
           希尔排序 n^1.5
           归并排序 nlogn
           冒泡排序 n^2

*/
