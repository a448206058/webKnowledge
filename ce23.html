<script>
  // 10
  // 5 5        25
  // 3 3 4      36
  // 2 2 2 3 1  24
  // 2 2 2 2 2  32

  // 1 1  1 1  1 1  1 1  1 1         1

  // 2  2  2  2  2                   32

  // 4 4 2                           32
  // 3 3 4

  // o o
  // o o
  // o o
  /**
   * @param {number} m
   * @param {number} n
   * @return {number}
   */
  // 3,2,3,null,3,null,1
  //       3
  //   2          3
  //null 3   null   1

  // 1, 2, 3, 0, 2
  // 1 3

  // nums = [1,2,3], target = 4
  // f(n) = f(n-1) + 1

  var combinationSum4 = function (nums, target) {
    const dp = new Array(target + 1).fill(0);
    dp[0] = 1;
    for (let i = 1; i <= target; i++) {
        for (const num of nums) {
            if (num <= i) {
                dp[i] += dp[i - num];
            }
        }
    }
    return dp[target];
  };

  var coinChange = function(coins, amount) {
    let dp = new Array(amount + 1).fill(Infinity);
    dp[0] = 0;

    for (let i = 1; i <= amount; i++) {
        for (let coin of coins) {
            if (i - coin >= 0) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }

    return dp[amount] === Infinity ? -1 : dp[amount];
};

  var wiggleMaxLength = function (nums) {
    if (nums.length < 2) return nums.length
    let up = 1, down = 1
    for (let i = 1; i < nums.length; i++)
      if (nums[i] > nums[i - 1])
        up = Math.max(up, down + 1)
      else if (nums[i] < nums[i - 1])
        down = Math.max(down, up + 1)
    return Math.max(up, down)
  };

  var maxProfit = function (prices) {
    let rest = 0;
    let sold = 0;
    let hold = -Infinity;
    for (let price of prices) {
      let preSold = sold;
      let preHold = hold;
      hold = Math.max(preHold, rest - price);
      sold = preHold + price;
      rest = Math.max(rest, preSold);
    }
    return Math.max(rest, sold);
  };

  // const rob = (root) => {

  //   const helper = (root) => {
  //     if (root == null) return [0, 0];

  //     const left = helper(root.left);
  //     const right = helper(root.right);

  //     robExcludeRoot = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
  //     robIncludeRoot = root.val + left[0] + right[0];

  //     return [robExcludeRoot, robIncludeRoot];
  //   };

  //   const res = helper(root);

  //   return Math.max(res[0], res[1]);
  // };

  // const rob = (root) => {
  //   const dp = new Map();
  //   // 辅助函数返回打劫以root为根节点的子树的收益
  //   const helper = (root) => {
  //     // 递归的出口，遍历到null节点，两种状态下收益都是0
  //     if (root == null) return [0, 0];
  //     // 递归调用左右子树
  //     const left = helper(root.left);
  //     const right = helper(root.right);
  //     // 之前没遍历过当前节点
  //     if (!dp.has(root)) {
  //       // 在map中添加当前节点，和对应的res数组
  //       dp.set(root, [0, 0]);
  //     }
  //     // 获取当前节点对应的res数组
  //     const res = dp.get(root);
  //     // 将当前子树的两个状态记录到map中
  //     res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
  //     res[1] = root.val + left[0] + right[0];
  //     // 返回出这两个状态
  //     return res;
  //   };
  //   // 递归的入口
  //   const res = helper(root);
  //   // 两种状态下的最优解，取其大
  //   return Math.max(res[0], res[1]);
  // };

  // const dfs = (node) => {
  //   if (node === null) {
  //     return [0, 0];
  //   }
  //   const l = dfs(node.left);
  //   const r = dfs(node.right);
  //   const selected = node.val + l[1] + r[1];
  //   const notSelected = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);
  //   return [selected, notSelected];
  // }

  // const rootStatus = dfs(root);
  // return Math.max(rootStatus[0], rootStatus[1]);

  // var rob = function (nums) {
  //   const length = nums.length;
  //   if (length === 1) {
  //     return nums[0];
  //   } else if (length === 2) {
  //     return Math.max(nums[0], nums[1]);
  //   }

  //   const robRange = (nums, start, end) => {
  //     let first = nums[start],
  //       second = Math.max(nums[start], nums[start + 1]);
  //     for (let i = start + 2; i <= end; i++) {
  //       const temp = second;
  //       second = Math.max(first + nums[i], second);
  //       first = temp;
  //     }
  //     return second;
  //   }
  //   return Math.max(
  //     robRange(nums, 0, length - 2),
  //     robRange(nums, 1, length - 1)
  //   )
  // };

  var rob = function (nums) {
    let n = nums.length;
    if (n == 0) return 0;

    let memo = new Array(n).fill(-1);
    memo[n - 1] = nums[n - 1];
    for (let i = n - 2; i >= 0; i--) {
      for (let j = i; j < n; j++) {
        if (i == 0) {
          continue;
        }
        memo[i] = Math.max(memo[i], nums[j] + (j + 2 < n ? memo[j + 2] : 0));
      }
    }
    return memo[0];
  };

  var rob = function (nums) {
    const length = nums.length;
    if (length === 1) {
      return nums[0];
    } else if (length === 2) {
      return Math.max(nums[0], nums[1]);
    }
    return Math.max(
      robRange(nums, 0, length - 2),
      robRange(nums, 1, length - 1)
    );
  };

  const robRange = (nums, start, end) => {
    let first = nums[start],
      second = Math.max(nums[start], nums[start + 1]);
    for (let i = start + 2; i <= end; i++) {
      const temp = second;
      second = Math.max(first + nums[i], second);
      first = temp;
    }
    return second;
  };

  var uniquePaths = function (m, n) {
    let dp = new Array(m);

    for (let i = 0; i < dp.length; i++) {
      if (i > 0) {
        dp[i] = [1];

        for (let j = 1; j < n; j++) {
          dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
      } else {
        dp[i] = new Array(n).fill(1);
      }
    }
    return dp[m - 1][n - 1];
  };

  var numDecodings = function (s) {
    const n = s.length;
    const value = new Array(n + 1).fill(0);
    value[0] = 1;
    for (let i = 1; i <= n; ++i) {
      if (s[i] != "0") {
        value[i] += value[i - 1];
      }
      if (
        i > 1 &&
        s[i - 2] != "0" &&
        (s[i - 2] - "0") * 10 + (s[i - 1] - "0") <= 26
      ) {
        value[i] += value[i - 2];
      }
    }
    return value[n];
  };

  // var integerBreak = function (n) {
  //   const dp = new Array(n + 1);
  //   dp[1] = 1;
  //   dp[2] = 1;
  //   for (let i = 3; i <= n; i++) {
  //     dp[i] = 0;
  //     for (let j = 1; j <= i - j; j++) {
  //       dp[i] = Math.max(dp[i], j * (i - j), j * dp[i - j])
  //     }
  //   }
  //   return dp[n];
  // };

  // console.log(integerBreak(10))

  // 0 0
  // "1" 1
  // "12" 2 [1, 2] [12]
  // "123" 3 [1, 2, 3], [12, 3] [1, 23]
  // "1234" 7  [1, 2, 3, 4],[1, 23, 4],[1, 2, 34], [12, 34], [123, 4], [1, 234], [1234]

  // let s = "1234"
  // let value = [[0, 1], [0, 0]]
  // let value = [[0,0,0],[0,1,0],[0,0,0]]
  let value = [[0]];
  // let value = [[1, 0]]

  let nums = [1,2,3], target = 4
  console.log(combinationSum4(nums, target));
</script>