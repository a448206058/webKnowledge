<script>
  // var subsetsWithDup = function (nums) {
  //   var res = [];
  //   var map = new Map();
  //   if (nums.length == 0) {
  //     return res;
  //   }
  //   nums = nums.sort((a, b) => a - b);
  //   var dep = (c, start) => {
  //     if (c.length > nums.length) {
  //       return;
  //     }
  //     // if (map.has(c.slice().toString())) {
  //     //   return;
  //     // } else {
  //     //   map.set(c.slice().toString(), 1);
  //     //   res.push(c.slice());
  //     // }

  //     res.push(c.slice());

  //     if (nums[start - 1] === nums[start]) {
  //       return;
  //     }

  //     for (let i = start; i < nums.length; i++) {
  //       c.push(nums[i]);
  //       dep(c, i + 1);
  //       c.pop();
  //     }
  //   }
  //   dep([], 0)
  //   return res;
  // };

  var subsetsWithDup = function (nums) {
    var res = [];
    if (nums.length == 0) {
      return res;
    }
    nums = nums.sort((a, b) => a - b);
    var dep = (c, start, choosePre) => {
      if (c.length > nums.length) {
        return;
      }

      res.push(c.slice());

      for (let i = start; i < nums.length; i++) {
        if (i > start && nums[i] == nums[i - 1]) {
            continue;
        }
        c.push(nums[i]);
        dep(c, i + 1, true);
        c.pop();
      }
    }
    dep([], 0, false)
    return res;
  };

  // var subsetsWithDup = function (nums) {
  //   nums.sort((a, b) => a - b);
  //   let t = [], ans = [];
  //   const dfs = (choosePre, cur, nums) => {
  //     if (cur === nums.length) {
  //       ans.push(t.slice());
  //       return;
  //     }
  //     dfs(false, cur + 1, nums);
  //     if (!choosePre && cur > 0 && nums[cur - 1] === nums[cur]) {
  //       return;
  //     }
  //     t.push(nums[cur]);
  //     dfs(true, cur + 1, nums);
  //     t = t.slice(0, t.length - 1);
  //   }
  //   dfs(false, 0, nums);
  //   return ans;
  // };

  // [[],[1],[1,2],[1,2,2],[2],[2,2]]
  // [] [1]

  console.log(subsetsWithDup([1, 2, 2]));
</script>